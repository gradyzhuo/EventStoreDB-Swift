// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: persistent.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct EventStore_Client_PersistentSubscriptions_ReadReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: EventStore_Client_PersistentSubscriptions_ReadReq.OneOf_Content? = nil

  public var options: EventStore_Client_PersistentSubscriptions_ReadReq.Options {
    get {
      if case .options(let v)? = content {return v}
      return EventStore_Client_PersistentSubscriptions_ReadReq.Options()
    }
    set {content = .options(newValue)}
  }

  public var ack: EventStore_Client_PersistentSubscriptions_ReadReq.Ack {
    get {
      if case .ack(let v)? = content {return v}
      return EventStore_Client_PersistentSubscriptions_ReadReq.Ack()
    }
    set {content = .ack(newValue)}
  }

  public var nack: EventStore_Client_PersistentSubscriptions_ReadReq.Nack {
    get {
      if case .nack(let v)? = content {return v}
      return EventStore_Client_PersistentSubscriptions_ReadReq.Nack()
    }
    set {content = .nack(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable, Sendable {
    case options(EventStore_Client_PersistentSubscriptions_ReadReq.Options)
    case ack(EventStore_Client_PersistentSubscriptions_ReadReq.Ack)
    case nack(EventStore_Client_PersistentSubscriptions_ReadReq.Nack)

  }

  public struct Options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.OneOf_StreamOption? = nil

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {
        if case .streamIdentifier(let v)? = streamOption {return v}
        return EventStore_Client_StreamIdentifier()
      }
      set {streamOption = .streamIdentifier(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Empty()
      }
      set {streamOption = .all(newValue)}
    }

    public var groupName: String = String()

    public var bufferSize: Int32 = 0

    public var uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption {
      get {return _uuidOption ?? EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption()}
      set {_uuidOption = newValue}
    }
    /// Returns true if `uuidOption` has been explicitly set.
    public var hasUuidOption: Bool {return self._uuidOption != nil}
    /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
    public mutating func clearUuidOption() {self._uuidOption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case streamIdentifier(EventStore_Client_StreamIdentifier)
      case all(EventStore_Client_Empty)

    }

    public struct UUIDOption: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var content: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption.OneOf_Content? = nil

      public var structured: EventStore_Client_Empty {
        get {
          if case .structured(let v)? = content {return v}
          return EventStore_Client_Empty()
        }
        set {content = .structured(newValue)}
      }

      public var string: EventStore_Client_Empty {
        get {
          if case .string(let v)? = content {return v}
          return EventStore_Client_Empty()
        }
        set {content = .string(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Content: Equatable, Sendable {
        case structured(EventStore_Client_Empty)
        case string(EventStore_Client_Empty)

      }

      public init() {}
    }

    public init() {}

    fileprivate var _uuidOption: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption? = nil
  }

  public struct Ack: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Data = Data()

    public var ids: [EventStore_Client_UUID] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Nack: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Data = Data()

    public var ids: [EventStore_Client_UUID] = []

    public var action: EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action = .unknown

    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unknown // = 0
      case park // = 1
      case retry // = 2
      case skip // = 3
      case stop // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .park
        case 2: self = .retry
        case 3: self = .skip
        case 4: self = .stop
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .park: return 1
        case .retry: return 2
        case .skip: return 3
        case .stop: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action] = [
        .unknown,
        .park,
        .retry,
        .skip,
        .stop,
      ]

    }

    public init() {}
  }

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_ReadResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: EventStore_Client_PersistentSubscriptions_ReadResp.OneOf_Content? = nil

  public var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent {
    get {
      if case .event(let v)? = content {return v}
      return EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent()
    }
    set {content = .event(newValue)}
  }

  public var subscriptionConfirmation: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation {
    get {
      if case .subscriptionConfirmation(let v)? = content {return v}
      return EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation()
    }
    set {content = .subscriptionConfirmation(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable, Sendable {
    case event(EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent)
    case subscriptionConfirmation(EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation)

  }

  public struct ReadEvent: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
      get {return _storage._event ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent()}
      set {_uniqueStorage()._event = newValue}
    }
    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool {return _storage._event != nil}
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() {_uniqueStorage()._event = nil}

    public var link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent {
      get {return _storage._link ?? EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent()}
      set {_uniqueStorage()._link = newValue}
    }
    /// Returns true if `link` has been explicitly set.
    public var hasLink: Bool {return _storage._link != nil}
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    public mutating func clearLink() {_uniqueStorage()._link = nil}

    public var position: OneOf_Position? {
      get {return _storage._position}
      set {_uniqueStorage()._position = newValue}
    }

    public var commitPosition: UInt64 {
      get {
        if case .commitPosition(let v)? = _storage._position {return v}
        return 0
      }
      set {_uniqueStorage()._position = .commitPosition(newValue)}
    }

    public var noPosition: EventStore_Client_Empty {
      get {
        if case .noPosition(let v)? = _storage._position {return v}
        return EventStore_Client_Empty()
      }
      set {_uniqueStorage()._position = .noPosition(newValue)}
    }

    public var count: OneOf_Count? {
      get {return _storage._count}
      set {_uniqueStorage()._count = newValue}
    }

    public var retryCount: Int32 {
      get {
        if case .retryCount(let v)? = _storage._count {return v}
        return 0
      }
      set {_uniqueStorage()._count = .retryCount(newValue)}
    }

    public var noRetryCount: EventStore_Client_Empty {
      get {
        if case .noRetryCount(let v)? = _storage._count {return v}
        return EventStore_Client_Empty()
      }
      set {_uniqueStorage()._count = .noRetryCount(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Position: Equatable, Sendable {
      case commitPosition(UInt64)
      case noPosition(EventStore_Client_Empty)

    }

    public enum OneOf_Count: Equatable, Sendable {
      case retryCount(Int32)
      case noRetryCount(EventStore_Client_Empty)

    }

    public struct RecordedEvent: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: EventStore_Client_UUID {
        get {return _id ?? EventStore_Client_UUID()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      public var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      public mutating func clearID() {self._id = nil}

      public var streamIdentifier: EventStore_Client_StreamIdentifier {
        get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
        set {_streamIdentifier = newValue}
      }
      /// Returns true if `streamIdentifier` has been explicitly set.
      public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
      /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
      public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

      public var streamRevision: UInt64 = 0

      public var preparePosition: UInt64 = 0

      public var commitPosition: UInt64 = 0

      public var metadata: Dictionary<String,String> = [:]

      public var customMetadata: Data = Data()

      public var data: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _id: EventStore_Client_UUID? = nil
      fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct SubscriptionConfirmation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_CreateReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_CreateReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_CreateReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ConsumerStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case dispatchToSingle // = 0
    case roundRobin // = 1
    case pinned // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .dispatchToSingle
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dispatchToSingle
      case 1: self = .roundRobin
      case 2: self = .pinned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dispatchToSingle: return 0
      case .roundRobin: return 1
      case .pinned: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy] = [
      .dispatchToSingle,
      .roundRobin,
      .pinned,
    ]

  }

  public struct Options: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: OneOf_StreamOption? {
      get {return _storage._streamOption}
      set {_uniqueStorage()._streamOption = newValue}
    }

    public var stream: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions {
      get {
        if case .stream(let v)? = _storage._streamOption {return v}
        return EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions()
      }
      set {_uniqueStorage()._streamOption = .stream(newValue)}
    }

    public var all: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions {
      get {
        if case .all(let v)? = _storage._streamOption {return v}
        return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions()
      }
      set {_uniqueStorage()._streamOption = .all(newValue)}
    }

    /// NOTE: This field was marked as deprecated in the .proto file.
    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_uniqueStorage()._streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return _storage._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {_uniqueStorage()._streamIdentifier = nil}

    public var groupName: String {
      get {return _storage._groupName}
      set {_uniqueStorage()._groupName = newValue}
    }

    public var settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings {
      get {return _storage._settings ?? EventStore_Client_PersistentSubscriptions_CreateReq.Settings()}
      set {_uniqueStorage()._settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    public var hasSettings: Bool {return _storage._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    public mutating func clearSettings() {_uniqueStorage()._settings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case stream(EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions)
      case all(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions)

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct StreamOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var revisionOption: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions.OneOf_RevisionOption? = nil

    public var revision: UInt64 {
      get {
        if case .revision(let v)? = revisionOption {return v}
        return 0
      }
      set {revisionOption = .revision(newValue)}
    }

    public var start: EventStore_Client_Empty {
      get {
        if case .start(let v)? = revisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {revisionOption = .start(newValue)}
    }

    public var end: EventStore_Client_Empty {
      get {
        if case .end(let v)? = revisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {revisionOption = .end(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_RevisionOption: Equatable, Sendable {
      case revision(UInt64)
      case start(EventStore_Client_Empty)
      case end(EventStore_Client_Empty)

    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public struct AllOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var allOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_AllOption? = nil

    public var position: EventStore_Client_PersistentSubscriptions_CreateReq.Position {
      get {
        if case .position(let v)? = allOption {return v}
        return EventStore_Client_PersistentSubscriptions_CreateReq.Position()
      }
      set {allOption = .position(newValue)}
    }

    public var start: EventStore_Client_Empty {
      get {
        if case .start(let v)? = allOption {return v}
        return EventStore_Client_Empty()
      }
      set {allOption = .start(newValue)}
    }

    public var end: EventStore_Client_Empty {
      get {
        if case .end(let v)? = allOption {return v}
        return EventStore_Client_Empty()
      }
      set {allOption = .end(newValue)}
    }

    public var filterOption: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.OneOf_FilterOption? = nil

    public var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions {
      get {
        if case .filter(let v)? = filterOption {return v}
        return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions()
      }
      set {filterOption = .filter(newValue)}
    }

    public var noFilter: EventStore_Client_Empty {
      get {
        if case .noFilter(let v)? = filterOption {return v}
        return EventStore_Client_Empty()
      }
      set {filterOption = .noFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_AllOption: Equatable, Sendable {
      case position(EventStore_Client_PersistentSubscriptions_CreateReq.Position)
      case start(EventStore_Client_Empty)
      case end(EventStore_Client_Empty)

    }

    public enum OneOf_FilterOption: Equatable, Sendable {
      case filter(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions)
      case noFilter(EventStore_Client_Empty)

    }

    public struct FilterOptions: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var filter: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Filter? = nil

      public var streamIdentifier: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
        get {
          if case .streamIdentifier(let v)? = filter {return v}
          return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
        }
        set {filter = .streamIdentifier(newValue)}
      }

      public var eventType: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression {
        get {
          if case .eventType(let v)? = filter {return v}
          return EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression()
        }
        set {filter = .eventType(newValue)}
      }

      public var window: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.OneOf_Window? = nil

      public var max: UInt32 {
        get {
          if case .max(let v)? = window {return v}
          return 0
        }
        set {window = .max(newValue)}
      }

      public var count: EventStore_Client_Empty {
        get {
          if case .count(let v)? = window {return v}
          return EventStore_Client_Empty()
        }
        set {window = .count(newValue)}
      }

      public var checkpointIntervalMultiplier: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Filter: Equatable, Sendable {
        case streamIdentifier(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)
        case eventType(EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression)

      }

      public enum OneOf_Window: Equatable, Sendable {
        case max(UInt32)
        case count(EventStore_Client_Empty)

      }

      public struct Expression: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var regex: String = String()

        public var prefix: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public struct Position: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Settings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var resolveLinks: Bool = false

    /// NOTE: This field was marked as deprecated in the .proto file.
    public var revision: UInt64 = 0

    public var extraStatistics: Bool = false

    public var maxRetryCount: Int32 = 0

    public var minCheckpointCount: Int32 = 0

    public var maxCheckpointCount: Int32 = 0

    public var maxSubscriberCount: Int32 = 0

    public var liveBufferSize: Int32 = 0

    public var readBatchSize: Int32 = 0

    public var historyBufferSize: Int32 = 0

    /// NOTE: This field was marked as deprecated in the .proto file.
    public var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy = .dispatchToSingle

    public var messageTimeout: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_MessageTimeout? = nil

    public var messageTimeoutTicks: Int64 {
      get {
        if case .messageTimeoutTicks(let v)? = messageTimeout {return v}
        return 0
      }
      set {messageTimeout = .messageTimeoutTicks(newValue)}
    }

    public var messageTimeoutMs: Int32 {
      get {
        if case .messageTimeoutMs(let v)? = messageTimeout {return v}
        return 0
      }
      set {messageTimeout = .messageTimeoutMs(newValue)}
    }

    public var checkpointAfter: EventStore_Client_PersistentSubscriptions_CreateReq.Settings.OneOf_CheckpointAfter? = nil

    public var checkpointAfterTicks: Int64 {
      get {
        if case .checkpointAfterTicks(let v)? = checkpointAfter {return v}
        return 0
      }
      set {checkpointAfter = .checkpointAfterTicks(newValue)}
    }

    public var checkpointAfterMs: Int32 {
      get {
        if case .checkpointAfterMs(let v)? = checkpointAfter {return v}
        return 0
      }
      set {checkpointAfter = .checkpointAfterMs(newValue)}
    }

    public var consumerStrategy: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MessageTimeout: Equatable, Sendable {
      case messageTimeoutTicks(Int64)
      case messageTimeoutMs(Int32)

    }

    public enum OneOf_CheckpointAfter: Equatable, Sendable {
      case checkpointAfterTicks(Int64)
      case checkpointAfterMs(Int32)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_CreateReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_CreateResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_UpdateReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ConsumerStrategy: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case dispatchToSingle // = 0
    case roundRobin // = 1
    case pinned // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .dispatchToSingle
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dispatchToSingle
      case 1: self = .roundRobin
      case 2: self = .pinned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dispatchToSingle: return 0
      case .roundRobin: return 1
      case .pinned: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy] = [
      .dispatchToSingle,
      .roundRobin,
      .pinned,
    ]

  }

  public struct Options: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: OneOf_StreamOption? {
      get {return _storage._streamOption}
      set {_uniqueStorage()._streamOption = newValue}
    }

    public var stream: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions {
      get {
        if case .stream(let v)? = _storage._streamOption {return v}
        return EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions()
      }
      set {_uniqueStorage()._streamOption = .stream(newValue)}
    }

    public var all: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions {
      get {
        if case .all(let v)? = _storage._streamOption {return v}
        return EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions()
      }
      set {_uniqueStorage()._streamOption = .all(newValue)}
    }

    /// NOTE: This field was marked as deprecated in the .proto file.
    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _storage._streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_uniqueStorage()._streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return _storage._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {_uniqueStorage()._streamIdentifier = nil}

    public var groupName: String {
      get {return _storage._groupName}
      set {_uniqueStorage()._groupName = newValue}
    }

    public var settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings {
      get {return _storage._settings ?? EventStore_Client_PersistentSubscriptions_UpdateReq.Settings()}
      set {_uniqueStorage()._settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    public var hasSettings: Bool {return _storage._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    public mutating func clearSettings() {_uniqueStorage()._settings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case stream(EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions)
      case all(EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions)

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct StreamOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var revisionOption: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions.OneOf_RevisionOption? = nil

    public var revision: UInt64 {
      get {
        if case .revision(let v)? = revisionOption {return v}
        return 0
      }
      set {revisionOption = .revision(newValue)}
    }

    public var start: EventStore_Client_Empty {
      get {
        if case .start(let v)? = revisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {revisionOption = .start(newValue)}
    }

    public var end: EventStore_Client_Empty {
      get {
        if case .end(let v)? = revisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {revisionOption = .end(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_RevisionOption: Equatable, Sendable {
      case revision(UInt64)
      case start(EventStore_Client_Empty)
      case end(EventStore_Client_Empty)

    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public struct AllOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var allOption: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions.OneOf_AllOption? = nil

    public var position: EventStore_Client_PersistentSubscriptions_UpdateReq.Position {
      get {
        if case .position(let v)? = allOption {return v}
        return EventStore_Client_PersistentSubscriptions_UpdateReq.Position()
      }
      set {allOption = .position(newValue)}
    }

    public var start: EventStore_Client_Empty {
      get {
        if case .start(let v)? = allOption {return v}
        return EventStore_Client_Empty()
      }
      set {allOption = .start(newValue)}
    }

    public var end: EventStore_Client_Empty {
      get {
        if case .end(let v)? = allOption {return v}
        return EventStore_Client_Empty()
      }
      set {allOption = .end(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_AllOption: Equatable, Sendable {
      case position(EventStore_Client_PersistentSubscriptions_UpdateReq.Position)
      case start(EventStore_Client_Empty)
      case end(EventStore_Client_Empty)

    }

    public init() {}
  }

  public struct Position: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Settings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var resolveLinks: Bool = false

    /// NOTE: This field was marked as deprecated in the .proto file.
    public var revision: UInt64 = 0

    public var extraStatistics: Bool = false

    public var maxRetryCount: Int32 = 0

    public var minCheckpointCount: Int32 = 0

    public var maxCheckpointCount: Int32 = 0

    public var maxSubscriberCount: Int32 = 0

    public var liveBufferSize: Int32 = 0

    public var readBatchSize: Int32 = 0

    public var historyBufferSize: Int32 = 0

    public var namedConsumerStrategy: EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy = .dispatchToSingle

    public var messageTimeout: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_MessageTimeout? = nil

    public var messageTimeoutTicks: Int64 {
      get {
        if case .messageTimeoutTicks(let v)? = messageTimeout {return v}
        return 0
      }
      set {messageTimeout = .messageTimeoutTicks(newValue)}
    }

    public var messageTimeoutMs: Int32 {
      get {
        if case .messageTimeoutMs(let v)? = messageTimeout {return v}
        return 0
      }
      set {messageTimeout = .messageTimeoutMs(newValue)}
    }

    public var checkpointAfter: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings.OneOf_CheckpointAfter? = nil

    public var checkpointAfterTicks: Int64 {
      get {
        if case .checkpointAfterTicks(let v)? = checkpointAfter {return v}
        return 0
      }
      set {checkpointAfter = .checkpointAfterTicks(newValue)}
    }

    public var checkpointAfterMs: Int32 {
      get {
        if case .checkpointAfterMs(let v)? = checkpointAfter {return v}
        return 0
      }
      set {checkpointAfter = .checkpointAfterMs(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_MessageTimeout: Equatable, Sendable {
      case messageTimeoutTicks(Int64)
      case messageTimeoutMs(Int32)

    }

    public enum OneOf_CheckpointAfter: Equatable, Sendable {
      case checkpointAfterTicks(Int64)
      case checkpointAfterMs(Int32)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_UpdateReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_UpdateResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_DeleteReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_DeleteReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: EventStore_Client_PersistentSubscriptions_DeleteReq.Options.OneOf_StreamOption? = nil

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {
        if case .streamIdentifier(let v)? = streamOption {return v}
        return EventStore_Client_StreamIdentifier()
      }
      set {streamOption = .streamIdentifier(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Empty()
      }
      set {streamOption = .all(newValue)}
    }

    public var groupName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case streamIdentifier(EventStore_Client_StreamIdentifier)
      case all(EventStore_Client_Empty)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_DeleteReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_DeleteResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_GetInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_GetInfoReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options.OneOf_StreamOption? = nil

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {
        if case .streamIdentifier(let v)? = streamOption {return v}
        return EventStore_Client_StreamIdentifier()
      }
      set {streamOption = .streamIdentifier(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Empty()
      }
      set {streamOption = .all(newValue)}
    }

    public var groupName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case streamIdentifier(EventStore_Client_StreamIdentifier)
      case all(EventStore_Client_Empty)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_GetInfoResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo {
    get {return _subscriptionInfo ?? EventStore_Client_PersistentSubscriptions_SubscriptionInfo()}
    set {_subscriptionInfo = newValue}
  }
  /// Returns true if `subscriptionInfo` has been explicitly set.
  public var hasSubscriptionInfo: Bool {return self._subscriptionInfo != nil}
  /// Clears the value of `subscriptionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSubscriptionInfo() {self._subscriptionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _subscriptionInfo: EventStore_Client_PersistentSubscriptions_SubscriptionInfo? = nil
}

public struct EventStore_Client_PersistentSubscriptions_SubscriptionInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var eventSource: String {
    get {return _storage._eventSource}
    set {_uniqueStorage()._eventSource = newValue}
  }

  public var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] {
    get {return _storage._connections}
    set {_uniqueStorage()._connections = newValue}
  }

  public var averagePerSecond: Int32 {
    get {return _storage._averagePerSecond}
    set {_uniqueStorage()._averagePerSecond = newValue}
  }

  public var totalItems: Int64 {
    get {return _storage._totalItems}
    set {_uniqueStorage()._totalItems = newValue}
  }

  public var countSinceLastMeasurement: Int64 {
    get {return _storage._countSinceLastMeasurement}
    set {_uniqueStorage()._countSinceLastMeasurement = newValue}
  }

  public var lastCheckpointedEventPosition: String {
    get {return _storage._lastCheckpointedEventPosition}
    set {_uniqueStorage()._lastCheckpointedEventPosition = newValue}
  }

  public var lastKnownEventPosition: String {
    get {return _storage._lastKnownEventPosition}
    set {_uniqueStorage()._lastKnownEventPosition = newValue}
  }

  public var resolveLinkTos: Bool {
    get {return _storage._resolveLinkTos}
    set {_uniqueStorage()._resolveLinkTos = newValue}
  }

  public var startFrom: String {
    get {return _storage._startFrom}
    set {_uniqueStorage()._startFrom = newValue}
  }

  public var messageTimeoutMilliseconds: Int32 {
    get {return _storage._messageTimeoutMilliseconds}
    set {_uniqueStorage()._messageTimeoutMilliseconds = newValue}
  }

  public var extraStatistics: Bool {
    get {return _storage._extraStatistics}
    set {_uniqueStorage()._extraStatistics = newValue}
  }

  public var maxRetryCount: Int32 {
    get {return _storage._maxRetryCount}
    set {_uniqueStorage()._maxRetryCount = newValue}
  }

  public var liveBufferSize: Int32 {
    get {return _storage._liveBufferSize}
    set {_uniqueStorage()._liveBufferSize = newValue}
  }

  public var bufferSize: Int32 {
    get {return _storage._bufferSize}
    set {_uniqueStorage()._bufferSize = newValue}
  }

  public var readBatchSize: Int32 {
    get {return _storage._readBatchSize}
    set {_uniqueStorage()._readBatchSize = newValue}
  }

  public var checkPointAfterMilliseconds: Int32 {
    get {return _storage._checkPointAfterMilliseconds}
    set {_uniqueStorage()._checkPointAfterMilliseconds = newValue}
  }

  public var minCheckPointCount: Int32 {
    get {return _storage._minCheckPointCount}
    set {_uniqueStorage()._minCheckPointCount = newValue}
  }

  public var maxCheckPointCount: Int32 {
    get {return _storage._maxCheckPointCount}
    set {_uniqueStorage()._maxCheckPointCount = newValue}
  }

  public var readBufferCount: Int32 {
    get {return _storage._readBufferCount}
    set {_uniqueStorage()._readBufferCount = newValue}
  }

  public var liveBufferCount: Int64 {
    get {return _storage._liveBufferCount}
    set {_uniqueStorage()._liveBufferCount = newValue}
  }

  public var retryBufferCount: Int32 {
    get {return _storage._retryBufferCount}
    set {_uniqueStorage()._retryBufferCount = newValue}
  }

  public var totalInFlightMessages: Int32 {
    get {return _storage._totalInFlightMessages}
    set {_uniqueStorage()._totalInFlightMessages = newValue}
  }

  public var outstandingMessagesCount: Int32 {
    get {return _storage._outstandingMessagesCount}
    set {_uniqueStorage()._outstandingMessagesCount = newValue}
  }

  public var namedConsumerStrategy: String {
    get {return _storage._namedConsumerStrategy}
    set {_uniqueStorage()._namedConsumerStrategy = newValue}
  }

  public var maxSubscriberCount: Int32 {
    get {return _storage._maxSubscriberCount}
    set {_uniqueStorage()._maxSubscriberCount = newValue}
  }

  public var parkedMessageCount: Int64 {
    get {return _storage._parkedMessageCount}
    set {_uniqueStorage()._parkedMessageCount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ConnectionInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var from: String = String()

    public var username: String = String()

    public var averageItemsPerSecond: Int32 = 0

    public var totalItems: Int64 = 0

    public var countSinceLastMeasurement: Int64 = 0

    public var observedMeasurements: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement] = []

    public var availableSlots: Int32 = 0

    public var inFlightMessages: Int32 = 0

    public var connectionName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Measurement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct EventStore_Client_PersistentSubscriptions_ReplayParkedReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var groupName: String = String()

    public var streamOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StreamOption? = nil

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {
        if case .streamIdentifier(let v)? = streamOption {return v}
        return EventStore_Client_StreamIdentifier()
      }
      set {streamOption = .streamIdentifier(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Empty()
      }
      set {streamOption = .all(newValue)}
    }

    public var stopAtOption: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options.OneOf_StopAtOption? = nil

    public var stopAt: Int64 {
      get {
        if case .stopAt(let v)? = stopAtOption {return v}
        return 0
      }
      set {stopAtOption = .stopAt(newValue)}
    }

    public var noLimit: EventStore_Client_Empty {
      get {
        if case .noLimit(let v)? = stopAtOption {return v}
        return EventStore_Client_Empty()
      }
      set {stopAtOption = .noLimit(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case streamIdentifier(EventStore_Client_StreamIdentifier)
      case all(EventStore_Client_Empty)

    }

    public enum OneOf_StopAtOption: Equatable, Sendable {
      case stopAt(Int64)
      case noLimit(EventStore_Client_Empty)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_ReplayParkedResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_PersistentSubscriptions_ListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_PersistentSubscriptions_ListReq.Options {
    get {return _options ?? EventStore_Client_PersistentSubscriptions_ListReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var listOption: EventStore_Client_PersistentSubscriptions_ListReq.Options.OneOf_ListOption? = nil

    public var listAllSubscriptions: EventStore_Client_Empty {
      get {
        if case .listAllSubscriptions(let v)? = listOption {return v}
        return EventStore_Client_Empty()
      }
      set {listOption = .listAllSubscriptions(newValue)}
    }

    public var listForStream: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption {
      get {
        if case .listForStream(let v)? = listOption {return v}
        return EventStore_Client_PersistentSubscriptions_ListReq.StreamOption()
      }
      set {listOption = .listForStream(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ListOption: Equatable, Sendable {
      case listAllSubscriptions(EventStore_Client_Empty)
      case listForStream(EventStore_Client_PersistentSubscriptions_ListReq.StreamOption)

    }

    public init() {}
  }

  public struct StreamOption: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption.OneOf_StreamOption? = nil

    public var stream: EventStore_Client_StreamIdentifier {
      get {
        if case .stream(let v)? = streamOption {return v}
        return EventStore_Client_StreamIdentifier()
      }
      set {streamOption = .stream(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Empty()
      }
      set {streamOption = .all(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable, Sendable {
      case stream(EventStore_Client_StreamIdentifier)
      case all(EventStore_Client_Empty)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_PersistentSubscriptions_ListReq.Options? = nil
}

public struct EventStore_Client_PersistentSubscriptions_ListResp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subscriptions: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event_store.client.persistent_subscriptions"

extension EventStore_Client_PersistentSubscriptions_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .same(proto: "ack"),
    3: .same(proto: "nack"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_PersistentSubscriptions_ReadReq.Options?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .options(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .options(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_PersistentSubscriptions_ReadReq.Ack?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .ack(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_PersistentSubscriptions_ReadReq.Nack?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .nack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .nack(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .options?: try {
      guard case .options(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .nack?: try {
      guard case .nack(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadReq, rhs: EventStore_Client_PersistentSubscriptions_ReadReq) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    5: .same(proto: "all"),
    2: .standard(proto: "group_name"),
    3: .standard(proto: "buffer_size"),
    4: .standard(proto: "uuid_option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_StreamIdentifier?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .streamIdentifier(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.bufferSize) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._uuidOption) }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .streamIdentifier(let v)? = self.streamOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.bufferSize, fieldNumber: 3)
    }
    try { if let v = self._uuidOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .all(let v)? = self.streamOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options) -> Bool {
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs._uuidOption != rhs._uuidOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.Options.protoMessageName + ".UUIDOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "structured"),
    2: .same(proto: "string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .structured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .structured(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .string(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .structured?: try {
      guard case .structured(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .string?: try {
      guard case .string(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Options.UUIDOption) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Ack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadReq.protoMessageName + ".Nack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "ids"),
    3: .same(proto: "action"),
    4: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 2)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack, rhs: EventStore_Client_PersistentSubscriptions_ReadReq.Nack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.action != rhs.action {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadReq.Nack.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Unknown"),
    1: .same(proto: "Park"),
    2: .same(proto: "Retry"),
    3: .same(proto: "Skip"),
    4: .same(proto: "Stop"),
  ]
}

extension EventStore_Client_PersistentSubscriptions_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .standard(proto: "subscription_confirmation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .event(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .subscriptionConfirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .subscriptionConfirmation(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .event?: try {
      guard case .event(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscriptionConfirmation?: try {
      guard case .subscriptionConfirmation(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadResp, rhs: EventStore_Client_PersistentSubscriptions_ReadResp) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".ReadEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "link"),
    3: .standard(proto: "commit_position"),
    4: .standard(proto: "no_position"),
    5: .standard(proto: "retry_count"),
    6: .standard(proto: "no_retry_count"),
  ]

  fileprivate class _StorageClass {
    var _event: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent? = nil
    var _link: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent? = nil
    var _position: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Position?
    var _count: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.OneOf_Count?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _event = source._event
      _link = source._link
      _position = source._position
      _count = source._count
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._link) }()
        case 3: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._position != nil {try decoder.handleConflictingOneOf()}
            _storage._position = .commitPosition(v)
          }
        }()
        case 4: try {
          var v: EventStore_Client_Empty?
          var hadOneofValue = false
          if let current = _storage._position {
            hadOneofValue = true
            if case .noPosition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._position = .noPosition(v)
          }
        }()
        case 5: try {
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {
            if _storage._count != nil {try decoder.handleConflictingOneOf()}
            _storage._count = .retryCount(v)
          }
        }()
        case 6: try {
          var v: EventStore_Client_Empty?
          var hadOneofValue = false
          if let current = _storage._count {
            hadOneofValue = true
            if case .noRetryCount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._count = .noRetryCount(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      switch _storage._position {
      case .commitPosition?: try {
        guard case .commitPosition(let v)? = _storage._position else { preconditionFailure() }
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }()
      case .noPosition?: try {
        guard case .noPosition(let v)? = _storage._position else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
      switch _storage._count {
      case .retryCount?: try {
        guard case .retryCount(let v)? = _storage._count else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }()
      case .noRetryCount?: try {
        guard case .noRetryCount(let v)? = _storage._count else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._event != rhs_storage._event {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._count != rhs_storage._count {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "stream_identifier"),
    3: .standard(proto: "stream_revision"),
    4: .standard(proto: "prepare_position"),
    5: .standard(proto: "commit_position"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "custom_metadata"),
    8: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.streamRevision) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.customMetadata) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.streamRevision != 0 {
      try visitor.visitSingularUInt64Field(value: self.streamRevision, fieldNumber: 3)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 4)
    }
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 6)
    }
    if !self.customMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.customMetadata, fieldNumber: 7)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.ReadEvent.RecordedEvent) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.streamRevision != rhs.streamRevision {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.customMetadata != rhs.customMetadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReadResp.protoMessageName + ".SubscriptionConfirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_PersistentSubscriptions_ReadResp.SubscriptionConfirmation) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq, rhs: EventStore_Client_PersistentSubscriptions_CreateReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DispatchToSingle"),
    1: .same(proto: "RoundRobin"),
    2: .same(proto: "Pinned"),
  ]
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "stream"),
    5: .same(proto: "all"),
    1: .standard(proto: "stream_identifier"),
    2: .standard(proto: "group_name"),
    3: .same(proto: "settings"),
  ]

  fileprivate class _StorageClass {
    var _streamOption: EventStore_Client_PersistentSubscriptions_CreateReq.Options.OneOf_StreamOption?
    var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    var _groupName: String = String()
    var _settings: EventStore_Client_PersistentSubscriptions_CreateReq.Settings? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _streamOption = source._streamOption
      _streamIdentifier = source._streamIdentifier
      _groupName = source._groupName
      _settings = source._settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._settings) }()
        case 4: try {
          var v: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions?
          var hadOneofValue = false
          if let current = _storage._streamOption {
            hadOneofValue = true
            if case .stream(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._streamOption = .stream(v)
          }
        }()
        case 5: try {
          var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions?
          var hadOneofValue = false
          if let current = _storage._streamOption {
            hadOneofValue = true
            if case .all(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._streamOption = .all(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._streamIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
      }
      try { if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._streamOption {
      case .stream?: try {
        guard case .stream(let v)? = _storage._streamOption else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .all?: try {
        guard case .all(let v)? = _storage._streamOption else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Options) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._streamOption != rhs_storage._streamOption {return false}
        if _storage._streamIdentifier != rhs_storage._streamIdentifier {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._settings != rhs_storage._settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".StreamOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .same(proto: "start"),
    4: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.revisionOption != nil {try decoder.handleConflictingOneOf()}
          self.revisionOption = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .start(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .end(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.revisionOption {
    case .revision?: try {
      guard case .revision(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .start?: try {
      guard case .start(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .end?: try {
      guard case .end(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.StreamOptions) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.revisionOption != rhs.revisionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".AllOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
    4: .same(proto: "filter"),
    5: .standard(proto: "no_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_PersistentSubscriptions_CreateReq.Position?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .position(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .start(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .end(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions?
        var hadOneofValue = false
        if let current = self.filterOption {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterOption = .filter(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.filterOption {
          hadOneofValue = true
          if case .noFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterOption = .noFilter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.allOption {
    case .position?: try {
      guard case .position(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .start?: try {
      guard case .start(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .end?: try {
      guard case .end(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.filterOption {
    case .filter?: try {
      guard case .filter(let v)? = self.filterOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .noFilter?: try {
      guard case .noFilter(let v)? = self.filterOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions) -> Bool {
    if lhs.allOption != rhs.allOption {return false}
    if lhs.filterOption != rhs.filterOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.protoMessageName + ".FilterOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .standard(proto: "event_type"),
    3: .same(proto: "max"),
    4: .same(proto: "count"),
    5: .same(proto: "checkpointIntervalMultiplier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .streamIdentifier(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .eventType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .eventType(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.window != nil {try decoder.handleConflictingOneOf()}
          self.window = .max(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.window {
          hadOneofValue = true
          if case .count(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.window = .count(v)
        }
      }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.checkpointIntervalMultiplier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filter {
    case .streamIdentifier?: try {
      guard case .streamIdentifier(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .eventType?: try {
      guard case .eventType(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.window {
    case .max?: try {
      guard case .max(let v)? = self.window else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .count?: try {
      guard case .count(let v)? = self.window else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.checkpointIntervalMultiplier != 0 {
      try visitor.visitSingularUInt32Field(value: self.checkpointIntervalMultiplier, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.window != rhs.window {return false}
    if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.protoMessageName + ".Expression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regex"),
    2: .same(proto: "prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regex) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.prefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regex.isEmpty {
      try visitor.visitSingularStringField(value: self.regex, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.prefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.AllOptions.FilterOptions.Expression) -> Bool {
    if lhs.regex != rhs.regex {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_CreateReq.protoMessageName + ".Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resolve_links"),
    2: .same(proto: "revision"),
    3: .standard(proto: "extra_statistics"),
    5: .standard(proto: "max_retry_count"),
    7: .standard(proto: "min_checkpoint_count"),
    8: .standard(proto: "max_checkpoint_count"),
    9: .standard(proto: "max_subscriber_count"),
    10: .standard(proto: "live_buffer_size"),
    11: .standard(proto: "read_batch_size"),
    12: .standard(proto: "history_buffer_size"),
    13: .standard(proto: "named_consumer_strategy"),
    4: .standard(proto: "message_timeout_ticks"),
    14: .standard(proto: "message_timeout_ms"),
    6: .standard(proto: "checkpoint_after_ticks"),
    15: .standard(proto: "checkpoint_after_ms"),
    16: .standard(proto: "consumer_strategy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.resolveLinks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.revision) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.extraStatistics) }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.messageTimeout != nil {try decoder.handleConflictingOneOf()}
          self.messageTimeout = .messageTimeoutTicks(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxRetryCount) }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.checkpointAfter != nil {try decoder.handleConflictingOneOf()}
          self.checkpointAfter = .checkpointAfterTicks(v)
        }
      }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.minCheckpointCount) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.maxCheckpointCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.maxSubscriberCount) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.liveBufferSize) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.readBatchSize) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.historyBufferSize) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.namedConsumerStrategy) }()
      case 14: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.messageTimeout != nil {try decoder.handleConflictingOneOf()}
          self.messageTimeout = .messageTimeoutMs(v)
        }
      }()
      case 15: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.checkpointAfter != nil {try decoder.handleConflictingOneOf()}
          self.checkpointAfter = .checkpointAfterMs(v)
        }
      }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.consumerStrategy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.resolveLinks != false {
      try visitor.visitSingularBoolField(value: self.resolveLinks, fieldNumber: 1)
    }
    if self.revision != 0 {
      try visitor.visitSingularUInt64Field(value: self.revision, fieldNumber: 2)
    }
    if self.extraStatistics != false {
      try visitor.visitSingularBoolField(value: self.extraStatistics, fieldNumber: 3)
    }
    try { if case .messageTimeoutTicks(let v)? = self.messageTimeout {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    if self.maxRetryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRetryCount, fieldNumber: 5)
    }
    try { if case .checkpointAfterTicks(let v)? = self.checkpointAfter {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    if self.minCheckpointCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minCheckpointCount, fieldNumber: 7)
    }
    if self.maxCheckpointCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCheckpointCount, fieldNumber: 8)
    }
    if self.maxSubscriberCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSubscriberCount, fieldNumber: 9)
    }
    if self.liveBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.liveBufferSize, fieldNumber: 10)
    }
    if self.readBatchSize != 0 {
      try visitor.visitSingularInt32Field(value: self.readBatchSize, fieldNumber: 11)
    }
    if self.historyBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.historyBufferSize, fieldNumber: 12)
    }
    if self.namedConsumerStrategy != .dispatchToSingle {
      try visitor.visitSingularEnumField(value: self.namedConsumerStrategy, fieldNumber: 13)
    }
    try { if case .messageTimeoutMs(let v)? = self.messageTimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if case .checkpointAfterMs(let v)? = self.checkpointAfter {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
    } }()
    if !self.consumerStrategy.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerStrategy, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_CreateReq.Settings) -> Bool {
    if lhs.resolveLinks != rhs.resolveLinks {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.extraStatistics != rhs.extraStatistics {return false}
    if lhs.maxRetryCount != rhs.maxRetryCount {return false}
    if lhs.minCheckpointCount != rhs.minCheckpointCount {return false}
    if lhs.maxCheckpointCount != rhs.maxCheckpointCount {return false}
    if lhs.maxSubscriberCount != rhs.maxSubscriberCount {return false}
    if lhs.liveBufferSize != rhs.liveBufferSize {return false}
    if lhs.readBatchSize != rhs.readBatchSize {return false}
    if lhs.historyBufferSize != rhs.historyBufferSize {return false}
    if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy {return false}
    if lhs.messageTimeout != rhs.messageTimeout {return false}
    if lhs.checkpointAfter != rhs.checkpointAfter {return false}
    if lhs.consumerStrategy != rhs.consumerStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_CreateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_CreateResp, rhs: EventStore_Client_PersistentSubscriptions_CreateResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.ConsumerStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DispatchToSingle"),
    1: .same(proto: "RoundRobin"),
    2: .same(proto: "Pinned"),
  ]
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "stream"),
    5: .same(proto: "all"),
    1: .standard(proto: "stream_identifier"),
    2: .standard(proto: "group_name"),
    3: .same(proto: "settings"),
  ]

  fileprivate class _StorageClass {
    var _streamOption: EventStore_Client_PersistentSubscriptions_UpdateReq.Options.OneOf_StreamOption?
    var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    var _groupName: String = String()
    var _settings: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _streamOption = source._streamOption
      _streamIdentifier = source._streamIdentifier
      _groupName = source._groupName
      _settings = source._settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._streamIdentifier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._settings) }()
        case 4: try {
          var v: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions?
          var hadOneofValue = false
          if let current = _storage._streamOption {
            hadOneofValue = true
            if case .stream(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._streamOption = .stream(v)
          }
        }()
        case 5: try {
          var v: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions?
          var hadOneofValue = false
          if let current = _storage._streamOption {
            hadOneofValue = true
            if case .all(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._streamOption = .all(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._streamIdentifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
      }
      try { if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._streamOption {
      case .stream?: try {
        guard case .stream(let v)? = _storage._streamOption else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .all?: try {
        guard case .all(let v)? = _storage._streamOption else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Options) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._streamOption != rhs_storage._streamOption {return false}
        if _storage._streamIdentifier != rhs_storage._streamIdentifier {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._settings != rhs_storage._settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".StreamOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .same(proto: "start"),
    4: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.revisionOption != nil {try decoder.handleConflictingOneOf()}
          self.revisionOption = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .start(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .end(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.revisionOption {
    case .revision?: try {
      guard case .revision(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .start?: try {
      guard case .start(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .end?: try {
      guard case .end(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.StreamOptions) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.revisionOption != rhs.revisionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".AllOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_PersistentSubscriptions_UpdateReq.Position?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .position(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .start(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .end(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.allOption {
    case .position?: try {
      guard case .position(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .start?: try {
      guard case .start(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .end?: try {
      guard case .end(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.AllOptions) -> Bool {
    if lhs.allOption != rhs.allOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateReq.Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_UpdateReq.protoMessageName + ".Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resolve_links"),
    2: .same(proto: "revision"),
    3: .standard(proto: "extra_statistics"),
    5: .standard(proto: "max_retry_count"),
    7: .standard(proto: "min_checkpoint_count"),
    8: .standard(proto: "max_checkpoint_count"),
    9: .standard(proto: "max_subscriber_count"),
    10: .standard(proto: "live_buffer_size"),
    11: .standard(proto: "read_batch_size"),
    12: .standard(proto: "history_buffer_size"),
    13: .standard(proto: "named_consumer_strategy"),
    4: .standard(proto: "message_timeout_ticks"),
    14: .standard(proto: "message_timeout_ms"),
    6: .standard(proto: "checkpoint_after_ticks"),
    15: .standard(proto: "checkpoint_after_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.resolveLinks) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.revision) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.extraStatistics) }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.messageTimeout != nil {try decoder.handleConflictingOneOf()}
          self.messageTimeout = .messageTimeoutTicks(v)
        }
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxRetryCount) }()
      case 6: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.checkpointAfter != nil {try decoder.handleConflictingOneOf()}
          self.checkpointAfter = .checkpointAfterTicks(v)
        }
      }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.minCheckpointCount) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.maxCheckpointCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.maxSubscriberCount) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.liveBufferSize) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.readBatchSize) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.historyBufferSize) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.namedConsumerStrategy) }()
      case 14: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.messageTimeout != nil {try decoder.handleConflictingOneOf()}
          self.messageTimeout = .messageTimeoutMs(v)
        }
      }()
      case 15: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.checkpointAfter != nil {try decoder.handleConflictingOneOf()}
          self.checkpointAfter = .checkpointAfterMs(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.resolveLinks != false {
      try visitor.visitSingularBoolField(value: self.resolveLinks, fieldNumber: 1)
    }
    if self.revision != 0 {
      try visitor.visitSingularUInt64Field(value: self.revision, fieldNumber: 2)
    }
    if self.extraStatistics != false {
      try visitor.visitSingularBoolField(value: self.extraStatistics, fieldNumber: 3)
    }
    try { if case .messageTimeoutTicks(let v)? = self.messageTimeout {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    if self.maxRetryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRetryCount, fieldNumber: 5)
    }
    try { if case .checkpointAfterTicks(let v)? = self.checkpointAfter {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    if self.minCheckpointCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minCheckpointCount, fieldNumber: 7)
    }
    if self.maxCheckpointCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCheckpointCount, fieldNumber: 8)
    }
    if self.maxSubscriberCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSubscriberCount, fieldNumber: 9)
    }
    if self.liveBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.liveBufferSize, fieldNumber: 10)
    }
    if self.readBatchSize != 0 {
      try visitor.visitSingularInt32Field(value: self.readBatchSize, fieldNumber: 11)
    }
    if self.historyBufferSize != 0 {
      try visitor.visitSingularInt32Field(value: self.historyBufferSize, fieldNumber: 12)
    }
    if self.namedConsumerStrategy != .dispatchToSingle {
      try visitor.visitSingularEnumField(value: self.namedConsumerStrategy, fieldNumber: 13)
    }
    try { if case .messageTimeoutMs(let v)? = self.messageTimeout {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if case .checkpointAfterMs(let v)? = self.checkpointAfter {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings, rhs: EventStore_Client_PersistentSubscriptions_UpdateReq.Settings) -> Bool {
    if lhs.resolveLinks != rhs.resolveLinks {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.extraStatistics != rhs.extraStatistics {return false}
    if lhs.maxRetryCount != rhs.maxRetryCount {return false}
    if lhs.minCheckpointCount != rhs.minCheckpointCount {return false}
    if lhs.maxCheckpointCount != rhs.maxCheckpointCount {return false}
    if lhs.maxSubscriberCount != rhs.maxSubscriberCount {return false}
    if lhs.liveBufferSize != rhs.liveBufferSize {return false}
    if lhs.readBatchSize != rhs.readBatchSize {return false}
    if lhs.historyBufferSize != rhs.historyBufferSize {return false}
    if lhs.namedConsumerStrategy != rhs.namedConsumerStrategy {return false}
    if lhs.messageTimeout != rhs.messageTimeout {return false}
    if lhs.checkpointAfter != rhs.checkpointAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_UpdateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_UpdateResp, rhs: EventStore_Client_PersistentSubscriptions_UpdateResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_DeleteReq, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_DeleteReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    3: .same(proto: "all"),
    2: .standard(proto: "group_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_StreamIdentifier?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .streamIdentifier(v)
        }
      }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .streamIdentifier(let v)? = self.streamOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    try { if case .all(let v)? = self.streamOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options, rhs: EventStore_Client_PersistentSubscriptions_DeleteReq.Options) -> Bool {
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_DeleteResp, rhs: EventStore_Client_PersistentSubscriptions_DeleteResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_GetInfoReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "all"),
    3: .standard(proto: "group_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_StreamIdentifier?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .streamIdentifier(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.streamOption {
    case .streamIdentifier?: try {
      guard case .streamIdentifier(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .all?: try {
      guard case .all(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options, rhs: EventStore_Client_PersistentSubscriptions_GetInfoReq.Options) -> Bool {
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_GetInfoResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInfoResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscriptionInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscriptionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_GetInfoResp, rhs: EventStore_Client_PersistentSubscriptions_GetInfoResp) -> Bool {
    if lhs._subscriptionInfo != rhs._subscriptionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscriptionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_source"),
    2: .standard(proto: "group_name"),
    3: .same(proto: "status"),
    4: .same(proto: "connections"),
    5: .standard(proto: "average_per_second"),
    6: .standard(proto: "total_items"),
    7: .standard(proto: "count_since_last_measurement"),
    8: .standard(proto: "last_checkpointed_event_position"),
    9: .standard(proto: "last_known_event_position"),
    10: .standard(proto: "resolve_link_tos"),
    11: .standard(proto: "start_from"),
    12: .standard(proto: "message_timeout_milliseconds"),
    13: .standard(proto: "extra_statistics"),
    14: .standard(proto: "max_retry_count"),
    15: .standard(proto: "live_buffer_size"),
    16: .standard(proto: "buffer_size"),
    17: .standard(proto: "read_batch_size"),
    18: .standard(proto: "check_point_after_milliseconds"),
    19: .standard(proto: "min_check_point_count"),
    20: .standard(proto: "max_check_point_count"),
    21: .standard(proto: "read_buffer_count"),
    22: .standard(proto: "live_buffer_count"),
    23: .standard(proto: "retry_buffer_count"),
    24: .standard(proto: "total_in_flight_messages"),
    25: .standard(proto: "outstanding_messages_count"),
    26: .standard(proto: "named_consumer_strategy"),
    27: .standard(proto: "max_subscriber_count"),
    28: .standard(proto: "parked_message_count"),
  ]

  fileprivate class _StorageClass {
    var _eventSource: String = String()
    var _groupName: String = String()
    var _status: String = String()
    var _connections: [EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo] = []
    var _averagePerSecond: Int32 = 0
    var _totalItems: Int64 = 0
    var _countSinceLastMeasurement: Int64 = 0
    var _lastCheckpointedEventPosition: String = String()
    var _lastKnownEventPosition: String = String()
    var _resolveLinkTos: Bool = false
    var _startFrom: String = String()
    var _messageTimeoutMilliseconds: Int32 = 0
    var _extraStatistics: Bool = false
    var _maxRetryCount: Int32 = 0
    var _liveBufferSize: Int32 = 0
    var _bufferSize: Int32 = 0
    var _readBatchSize: Int32 = 0
    var _checkPointAfterMilliseconds: Int32 = 0
    var _minCheckPointCount: Int32 = 0
    var _maxCheckPointCount: Int32 = 0
    var _readBufferCount: Int32 = 0
    var _liveBufferCount: Int64 = 0
    var _retryBufferCount: Int32 = 0
    var _totalInFlightMessages: Int32 = 0
    var _outstandingMessagesCount: Int32 = 0
    var _namedConsumerStrategy: String = String()
    var _maxSubscriberCount: Int32 = 0
    var _parkedMessageCount: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _eventSource = source._eventSource
      _groupName = source._groupName
      _status = source._status
      _connections = source._connections
      _averagePerSecond = source._averagePerSecond
      _totalItems = source._totalItems
      _countSinceLastMeasurement = source._countSinceLastMeasurement
      _lastCheckpointedEventPosition = source._lastCheckpointedEventPosition
      _lastKnownEventPosition = source._lastKnownEventPosition
      _resolveLinkTos = source._resolveLinkTos
      _startFrom = source._startFrom
      _messageTimeoutMilliseconds = source._messageTimeoutMilliseconds
      _extraStatistics = source._extraStatistics
      _maxRetryCount = source._maxRetryCount
      _liveBufferSize = source._liveBufferSize
      _bufferSize = source._bufferSize
      _readBatchSize = source._readBatchSize
      _checkPointAfterMilliseconds = source._checkPointAfterMilliseconds
      _minCheckPointCount = source._minCheckPointCount
      _maxCheckPointCount = source._maxCheckPointCount
      _readBufferCount = source._readBufferCount
      _liveBufferCount = source._liveBufferCount
      _retryBufferCount = source._retryBufferCount
      _totalInFlightMessages = source._totalInFlightMessages
      _outstandingMessagesCount = source._outstandingMessagesCount
      _namedConsumerStrategy = source._namedConsumerStrategy
      _maxSubscriberCount = source._maxSubscriberCount
      _parkedMessageCount = source._parkedMessageCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._eventSource) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._connections) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._averagePerSecond) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._totalItems) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._countSinceLastMeasurement) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._lastCheckpointedEventPosition) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._lastKnownEventPosition) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._resolveLinkTos) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._startFrom) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._messageTimeoutMilliseconds) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._extraStatistics) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._maxRetryCount) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._liveBufferSize) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._bufferSize) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._readBatchSize) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._checkPointAfterMilliseconds) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._minCheckPointCount) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._maxCheckPointCount) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._readBufferCount) }()
        case 22: try { try decoder.decodeSingularInt64Field(value: &_storage._liveBufferCount) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._retryBufferCount) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._totalInFlightMessages) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._outstandingMessagesCount) }()
        case 26: try { try decoder.decodeSingularStringField(value: &_storage._namedConsumerStrategy) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._maxSubscriberCount) }()
        case 28: try { try decoder.decodeSingularInt64Field(value: &_storage._parkedMessageCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._eventSource.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventSource, fieldNumber: 1)
      }
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 2)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 3)
      }
      if !_storage._connections.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._connections, fieldNumber: 4)
      }
      if _storage._averagePerSecond != 0 {
        try visitor.visitSingularInt32Field(value: _storage._averagePerSecond, fieldNumber: 5)
      }
      if _storage._totalItems != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalItems, fieldNumber: 6)
      }
      if _storage._countSinceLastMeasurement != 0 {
        try visitor.visitSingularInt64Field(value: _storage._countSinceLastMeasurement, fieldNumber: 7)
      }
      if !_storage._lastCheckpointedEventPosition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastCheckpointedEventPosition, fieldNumber: 8)
      }
      if !_storage._lastKnownEventPosition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastKnownEventPosition, fieldNumber: 9)
      }
      if _storage._resolveLinkTos != false {
        try visitor.visitSingularBoolField(value: _storage._resolveLinkTos, fieldNumber: 10)
      }
      if !_storage._startFrom.isEmpty {
        try visitor.visitSingularStringField(value: _storage._startFrom, fieldNumber: 11)
      }
      if _storage._messageTimeoutMilliseconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._messageTimeoutMilliseconds, fieldNumber: 12)
      }
      if _storage._extraStatistics != false {
        try visitor.visitSingularBoolField(value: _storage._extraStatistics, fieldNumber: 13)
      }
      if _storage._maxRetryCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxRetryCount, fieldNumber: 14)
      }
      if _storage._liveBufferSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._liveBufferSize, fieldNumber: 15)
      }
      if _storage._bufferSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bufferSize, fieldNumber: 16)
      }
      if _storage._readBatchSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._readBatchSize, fieldNumber: 17)
      }
      if _storage._checkPointAfterMilliseconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._checkPointAfterMilliseconds, fieldNumber: 18)
      }
      if _storage._minCheckPointCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minCheckPointCount, fieldNumber: 19)
      }
      if _storage._maxCheckPointCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxCheckPointCount, fieldNumber: 20)
      }
      if _storage._readBufferCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._readBufferCount, fieldNumber: 21)
      }
      if _storage._liveBufferCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._liveBufferCount, fieldNumber: 22)
      }
      if _storage._retryBufferCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retryBufferCount, fieldNumber: 23)
      }
      if _storage._totalInFlightMessages != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalInFlightMessages, fieldNumber: 24)
      }
      if _storage._outstandingMessagesCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outstandingMessagesCount, fieldNumber: 25)
      }
      if !_storage._namedConsumerStrategy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namedConsumerStrategy, fieldNumber: 26)
      }
      if _storage._maxSubscriberCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxSubscriberCount, fieldNumber: 27)
      }
      if _storage._parkedMessageCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parkedMessageCount, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._eventSource != rhs_storage._eventSource {return false}
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._connections != rhs_storage._connections {return false}
        if _storage._averagePerSecond != rhs_storage._averagePerSecond {return false}
        if _storage._totalItems != rhs_storage._totalItems {return false}
        if _storage._countSinceLastMeasurement != rhs_storage._countSinceLastMeasurement {return false}
        if _storage._lastCheckpointedEventPosition != rhs_storage._lastCheckpointedEventPosition {return false}
        if _storage._lastKnownEventPosition != rhs_storage._lastKnownEventPosition {return false}
        if _storage._resolveLinkTos != rhs_storage._resolveLinkTos {return false}
        if _storage._startFrom != rhs_storage._startFrom {return false}
        if _storage._messageTimeoutMilliseconds != rhs_storage._messageTimeoutMilliseconds {return false}
        if _storage._extraStatistics != rhs_storage._extraStatistics {return false}
        if _storage._maxRetryCount != rhs_storage._maxRetryCount {return false}
        if _storage._liveBufferSize != rhs_storage._liveBufferSize {return false}
        if _storage._bufferSize != rhs_storage._bufferSize {return false}
        if _storage._readBatchSize != rhs_storage._readBatchSize {return false}
        if _storage._checkPointAfterMilliseconds != rhs_storage._checkPointAfterMilliseconds {return false}
        if _storage._minCheckPointCount != rhs_storage._minCheckPointCount {return false}
        if _storage._maxCheckPointCount != rhs_storage._maxCheckPointCount {return false}
        if _storage._readBufferCount != rhs_storage._readBufferCount {return false}
        if _storage._liveBufferCount != rhs_storage._liveBufferCount {return false}
        if _storage._retryBufferCount != rhs_storage._retryBufferCount {return false}
        if _storage._totalInFlightMessages != rhs_storage._totalInFlightMessages {return false}
        if _storage._outstandingMessagesCount != rhs_storage._outstandingMessagesCount {return false}
        if _storage._namedConsumerStrategy != rhs_storage._namedConsumerStrategy {return false}
        if _storage._maxSubscriberCount != rhs_storage._maxSubscriberCount {return false}
        if _storage._parkedMessageCount != rhs_storage._parkedMessageCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".ConnectionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "username"),
    3: .standard(proto: "average_items_per_second"),
    4: .standard(proto: "total_items"),
    5: .standard(proto: "count_since_last_measurement"),
    6: .standard(proto: "observed_measurements"),
    7: .standard(proto: "available_slots"),
    8: .standard(proto: "in_flight_messages"),
    9: .standard(proto: "connection_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.from) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.averageItemsPerSecond) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalItems) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.countSinceLastMeasurement) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.observedMeasurements) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.availableSlots) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.inFlightMessages) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.connectionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularStringField(value: self.from, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if self.averageItemsPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.averageItemsPerSecond, fieldNumber: 3)
    }
    if self.totalItems != 0 {
      try visitor.visitSingularInt64Field(value: self.totalItems, fieldNumber: 4)
    }
    if self.countSinceLastMeasurement != 0 {
      try visitor.visitSingularInt64Field(value: self.countSinceLastMeasurement, fieldNumber: 5)
    }
    if !self.observedMeasurements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.observedMeasurements, fieldNumber: 6)
    }
    if self.availableSlots != 0 {
      try visitor.visitSingularInt32Field(value: self.availableSlots, fieldNumber: 7)
    }
    if self.inFlightMessages != 0 {
      try visitor.visitSingularInt32Field(value: self.inFlightMessages, fieldNumber: 8)
    }
    if !self.connectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionName, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.ConnectionInfo) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.username != rhs.username {return false}
    if lhs.averageItemsPerSecond != rhs.averageItemsPerSecond {return false}
    if lhs.totalItems != rhs.totalItems {return false}
    if lhs.countSinceLastMeasurement != rhs.countSinceLastMeasurement {return false}
    if lhs.observedMeasurements != rhs.observedMeasurements {return false}
    if lhs.availableSlots != rhs.availableSlots {return false}
    if lhs.inFlightMessages != rhs.inFlightMessages {return false}
    if lhs.connectionName != rhs.connectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_SubscriptionInfo.protoMessageName + ".Measurement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement, rhs: EventStore_Client_PersistentSubscriptions_SubscriptionInfo.Measurement) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplayParkedReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ReplayParkedReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
    2: .standard(proto: "stream_identifier"),
    3: .same(proto: "all"),
    4: .standard(proto: "stop_at"),
    5: .standard(proto: "no_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 2: try {
        var v: EventStore_Client_StreamIdentifier?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .streamIdentifier(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      case 4: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.stopAtOption != nil {try decoder.handleConflictingOneOf()}
          self.stopAtOption = .stopAt(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.stopAtOption {
          hadOneofValue = true
          if case .noLimit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stopAtOption = .noLimit(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 1)
    }
    switch self.streamOption {
    case .streamIdentifier?: try {
      guard case .streamIdentifier(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .all?: try {
      guard case .all(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    switch self.stopAtOption {
    case .stopAt?: try {
      guard case .stopAt(let v)? = self.stopAtOption else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case .noLimit?: try {
      guard case .noLimit(let v)? = self.stopAtOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedReq.Options) -> Bool {
    if lhs.groupName != rhs.groupName {return false}
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.stopAtOption != rhs.stopAtOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ReplayParkedResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplayParkedResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp, rhs: EventStore_Client_PersistentSubscriptions_ReplayParkedResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ListReq, rhs: EventStore_Client_PersistentSubscriptions_ListReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_all_subscriptions"),
    2: .standard(proto: "list_for_stream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.listOption {
          hadOneofValue = true
          if case .listAllSubscriptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.listOption = .listAllSubscriptions(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption?
        var hadOneofValue = false
        if let current = self.listOption {
          hadOneofValue = true
          if case .listForStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.listOption = .listForStream(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.listOption {
    case .listAllSubscriptions?: try {
      guard case .listAllSubscriptions(let v)? = self.listOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .listForStream?: try {
      guard case .listForStream(let v)? = self.listOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ListReq.Options, rhs: EventStore_Client_PersistentSubscriptions_ListReq.Options) -> Bool {
    if lhs.listOption != rhs.listOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ListReq.StreamOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_PersistentSubscriptions_ListReq.protoMessageName + ".StreamOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_StreamIdentifier?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .stream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .stream(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.streamOption {
    case .stream?: try {
      guard case .stream(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .all?: try {
      guard case .all(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption, rhs: EventStore_Client_PersistentSubscriptions_ListReq.StreamOption) -> Bool {
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_PersistentSubscriptions_ListResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriptions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subscriptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscriptions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_PersistentSubscriptions_ListResp, rhs: EventStore_Client_PersistentSubscriptions_ListResp) -> Bool {
    if lhs.subscriptions != rhs.subscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
