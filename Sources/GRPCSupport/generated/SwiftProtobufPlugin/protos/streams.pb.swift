// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/streams.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct EventStore_Client_Streams_ReadReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Streams_ReadReq.Options {
    get {return _options ?? EventStore_Client_Streams_ReadReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamOption: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption? = nil

    public var stream: EventStore_Client_Streams_ReadReq.Options.StreamOptions {
      get {
        if case .stream(let v)? = streamOption {return v}
        return EventStore_Client_Streams_ReadReq.Options.StreamOptions()
      }
      set {streamOption = .stream(newValue)}
    }

    public var all: EventStore_Client_Streams_ReadReq.Options.AllOptions {
      get {
        if case .all(let v)? = streamOption {return v}
        return EventStore_Client_Streams_ReadReq.Options.AllOptions()
      }
      set {streamOption = .all(newValue)}
    }

    public var readDirection: EventStore_Client_Streams_ReadReq.Options.ReadDirection = .forwards

    public var resolveLinks: Bool = false

    public var countOption: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption? = nil

    public var count: UInt64 {
      get {
        if case .count(let v)? = countOption {return v}
        return 0
      }
      set {countOption = .count(newValue)}
    }

    public var subscription: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions {
      get {
        if case .subscription(let v)? = countOption {return v}
        return EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions()
      }
      set {countOption = .subscription(newValue)}
    }

    public var filterOption: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption? = nil

    public var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions {
      get {
        if case .filter(let v)? = filterOption {return v}
        return EventStore_Client_Streams_ReadReq.Options.FilterOptions()
      }
      set {filterOption = .filter(newValue)}
    }

    public var noFilter: EventStore_Client_Empty {
      get {
        if case .noFilter(let v)? = filterOption {return v}
        return EventStore_Client_Empty()
      }
      set {filterOption = .noFilter(newValue)}
    }

    public var uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption {
      get {return _uuidOption ?? EventStore_Client_Streams_ReadReq.Options.UUIDOption()}
      set {_uuidOption = newValue}
    }
    /// Returns true if `uuidOption` has been explicitly set.
    public var hasUuidOption: Bool {return self._uuidOption != nil}
    /// Clears the value of `uuidOption`. Subsequent reads from it will return its default value.
    public mutating func clearUuidOption() {self._uuidOption = nil}

    public var controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption {
      get {return _controlOption ?? EventStore_Client_Streams_ReadReq.Options.ControlOption()}
      set {_controlOption = newValue}
    }
    /// Returns true if `controlOption` has been explicitly set.
    public var hasControlOption: Bool {return self._controlOption != nil}
    /// Clears the value of `controlOption`. Subsequent reads from it will return its default value.
    public mutating func clearControlOption() {self._controlOption = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_StreamOption: Equatable {
      case stream(EventStore_Client_Streams_ReadReq.Options.StreamOptions)
      case all(EventStore_Client_Streams_ReadReq.Options.AllOptions)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.stream, .stream): return {
          guard case .stream(let l) = lhs, case .stream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.all, .all): return {
          guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_CountOption: Equatable {
      case count(UInt64)
      case subscription(EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.count, .count): return {
          guard case .count(let l) = lhs, case .count(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.subscription, .subscription): return {
          guard case .subscription(let l) = lhs, case .subscription(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_FilterOption: Equatable {
      case filter(EventStore_Client_Streams_ReadReq.Options.FilterOptions)
      case noFilter(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption, rhs: EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.filter, .filter): return {
          guard case .filter(let l) = lhs, case .filter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noFilter, .noFilter): return {
          guard case .noFilter(let l) = lhs, case .noFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum ReadDirection: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case forwards // = 0
      case backwards // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .forwards
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .forwards
        case 1: self = .backwards
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .forwards: return 0
        case .backwards: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public struct StreamOptions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var streamIdentifier: EventStore_Client_StreamIdentifier {
        get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
        set {_streamIdentifier = newValue}
      }
      /// Returns true if `streamIdentifier` has been explicitly set.
      public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
      /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
      public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

      public var revisionOption: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption? = nil

      public var revision: UInt64 {
        get {
          if case .revision(let v)? = revisionOption {return v}
          return 0
        }
        set {revisionOption = .revision(newValue)}
      }

      public var start: EventStore_Client_Empty {
        get {
          if case .start(let v)? = revisionOption {return v}
          return EventStore_Client_Empty()
        }
        set {revisionOption = .start(newValue)}
      }

      public var end: EventStore_Client_Empty {
        get {
          if case .end(let v)? = revisionOption {return v}
          return EventStore_Client_Empty()
        }
        set {revisionOption = .end(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_RevisionOption: Equatable {
        case revision(UInt64)
        case start(EventStore_Client_Empty)
        case end(EventStore_Client_Empty)

      #if !swift(>=4.1)
        public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption, rhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.revision, .revision): return {
            guard case .revision(let l) = lhs, case .revision(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.start, .start): return {
            guard case .start(let l) = lhs, case .start(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.end, .end): return {
            guard case .end(let l) = lhs, case .end(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}

      fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    public struct AllOptions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var allOption: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption? = nil

      public var position: EventStore_Client_Streams_ReadReq.Options.Position {
        get {
          if case .position(let v)? = allOption {return v}
          return EventStore_Client_Streams_ReadReq.Options.Position()
        }
        set {allOption = .position(newValue)}
      }

      public var start: EventStore_Client_Empty {
        get {
          if case .start(let v)? = allOption {return v}
          return EventStore_Client_Empty()
        }
        set {allOption = .start(newValue)}
      }

      public var end: EventStore_Client_Empty {
        get {
          if case .end(let v)? = allOption {return v}
          return EventStore_Client_Empty()
        }
        set {allOption = .end(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_AllOption: Equatable {
        case position(EventStore_Client_Streams_ReadReq.Options.Position)
        case start(EventStore_Client_Empty)
        case end(EventStore_Client_Empty)

      #if !swift(>=4.1)
        public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption, rhs: EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.position, .position): return {
            guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.start, .start): return {
            guard case .start(let l) = lhs, case .start(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.end, .end): return {
            guard case .end(let l) = lhs, case .end(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public struct SubscriptionOptions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Position {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var commitPosition: UInt64 = 0

      public var preparePosition: UInt64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct FilterOptions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var filter: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter? = nil

      public var streamIdentifier: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
        get {
          if case .streamIdentifier(let v)? = filter {return v}
          return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
        }
        set {filter = .streamIdentifier(newValue)}
      }

      public var eventType: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression {
        get {
          if case .eventType(let v)? = filter {return v}
          return EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression()
        }
        set {filter = .eventType(newValue)}
      }

      public var window: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window? = nil

      public var max: UInt32 {
        get {
          if case .max(let v)? = window {return v}
          return 0
        }
        set {window = .max(newValue)}
      }

      public var count: EventStore_Client_Empty {
        get {
          if case .count(let v)? = window {return v}
          return EventStore_Client_Empty()
        }
        set {window = .count(newValue)}
      }

      public var checkpointIntervalMultiplier: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Filter: Equatable {
        case streamIdentifier(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)
        case eventType(EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression)

      #if !swift(>=4.1)
        public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.streamIdentifier, .streamIdentifier): return {
            guard case .streamIdentifier(let l) = lhs, case .streamIdentifier(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.eventType, .eventType): return {
            guard case .eventType(let l) = lhs, case .eventType(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public enum OneOf_Window: Equatable {
        case max(UInt32)
        case count(EventStore_Client_Empty)

      #if !swift(>=4.1)
        public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.max, .max): return {
            guard case .max(let l) = lhs, case .max(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.count, .count): return {
            guard case .count(let l) = lhs, case .count(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public struct Expression {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var regex: String = String()

        public var prefix: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct UUIDOption {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var content: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content? = nil

      public var structured: EventStore_Client_Empty {
        get {
          if case .structured(let v)? = content {return v}
          return EventStore_Client_Empty()
        }
        set {content = .structured(newValue)}
      }

      public var string: EventStore_Client_Empty {
        get {
          if case .string(let v)? = content {return v}
          return EventStore_Client_Empty()
        }
        set {content = .string(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Content: Equatable {
        case structured(EventStore_Client_Empty)
        case string(EventStore_Client_Empty)

      #if !swift(>=4.1)
        public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content, rhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.structured, .structured): return {
            guard case .structured(let l) = lhs, case .structured(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.string, .string): return {
            guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public struct ControlOption {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var compatibility: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _uuidOption: EventStore_Client_Streams_ReadReq.Options.UUIDOption? = nil
    fileprivate var _controlOption: EventStore_Client_Streams_ReadReq.Options.ControlOption? = nil
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Streams_ReadReq.Options? = nil
}

#if swift(>=4.2)

extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [EventStore_Client_Streams_ReadReq.Options.ReadDirection] = [
    .forwards,
    .backwards,
  ]
}

#endif  // swift(>=4.2)

public struct EventStore_Client_Streams_ReadResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: EventStore_Client_Streams_ReadResp.OneOf_Content? = nil

  public var event: EventStore_Client_Streams_ReadResp.ReadEvent {
    get {
      if case .event(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.ReadEvent()
    }
    set {content = .event(newValue)}
  }

  public var confirmation: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation {
    get {
      if case .confirmation(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.SubscriptionConfirmation()
    }
    set {content = .confirmation(newValue)}
  }

  public var checkpoint: EventStore_Client_Streams_ReadResp.Checkpoint {
    get {
      if case .checkpoint(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.Checkpoint()
    }
    set {content = .checkpoint(newValue)}
  }

  public var streamNotFound: EventStore_Client_Streams_ReadResp.StreamNotFound {
    get {
      if case .streamNotFound(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.StreamNotFound()
    }
    set {content = .streamNotFound(newValue)}
  }

  public var firstStreamPosition: UInt64 {
    get {
      if case .firstStreamPosition(let v)? = content {return v}
      return 0
    }
    set {content = .firstStreamPosition(newValue)}
  }

  public var lastStreamPosition: UInt64 {
    get {
      if case .lastStreamPosition(let v)? = content {return v}
      return 0
    }
    set {content = .lastStreamPosition(newValue)}
  }

  public var lastAllStreamPosition: EventStore_Client_AllStreamPosition {
    get {
      if case .lastAllStreamPosition(let v)? = content {return v}
      return EventStore_Client_AllStreamPosition()
    }
    set {content = .lastAllStreamPosition(newValue)}
  }

  public var caughtUp: EventStore_Client_Streams_ReadResp.CaughtUp {
    get {
      if case .caughtUp(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.CaughtUp()
    }
    set {content = .caughtUp(newValue)}
  }

  public var fellBehind: EventStore_Client_Streams_ReadResp.FellBehind {
    get {
      if case .fellBehind(let v)? = content {return v}
      return EventStore_Client_Streams_ReadResp.FellBehind()
    }
    set {content = .fellBehind(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case event(EventStore_Client_Streams_ReadResp.ReadEvent)
    case confirmation(EventStore_Client_Streams_ReadResp.SubscriptionConfirmation)
    case checkpoint(EventStore_Client_Streams_ReadResp.Checkpoint)
    case streamNotFound(EventStore_Client_Streams_ReadResp.StreamNotFound)
    case firstStreamPosition(UInt64)
    case lastStreamPosition(UInt64)
    case lastAllStreamPosition(EventStore_Client_AllStreamPosition)
    case caughtUp(EventStore_Client_Streams_ReadResp.CaughtUp)
    case fellBehind(EventStore_Client_Streams_ReadResp.FellBehind)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_ReadResp.OneOf_Content, rhs: EventStore_Client_Streams_ReadResp.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.confirmation, .confirmation): return {
        guard case .confirmation(let l) = lhs, case .confirmation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkpoint, .checkpoint): return {
        guard case .checkpoint(let l) = lhs, case .checkpoint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamNotFound, .streamNotFound): return {
        guard case .streamNotFound(let l) = lhs, case .streamNotFound(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.firstStreamPosition, .firstStreamPosition): return {
        guard case .firstStreamPosition(let l) = lhs, case .firstStreamPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastStreamPosition, .lastStreamPosition): return {
        guard case .lastStreamPosition(let l) = lhs, case .lastStreamPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastAllStreamPosition, .lastAllStreamPosition): return {
        guard case .lastAllStreamPosition(let l) = lhs, case .lastAllStreamPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.caughtUp, .caughtUp): return {
        guard case .caughtUp(let l) = lhs, case .caughtUp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fellBehind, .fellBehind): return {
        guard case .fellBehind(let l) = lhs, case .fellBehind(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CaughtUp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct FellBehind {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ReadEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
      get {return _storage._event ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent()}
      set {_uniqueStorage()._event = newValue}
    }
    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool {return _storage._event != nil}
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() {_uniqueStorage()._event = nil}

    public var link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent {
      get {return _storage._link ?? EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent()}
      set {_uniqueStorage()._link = newValue}
    }
    /// Returns true if `link` has been explicitly set.
    public var hasLink: Bool {return _storage._link != nil}
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    public mutating func clearLink() {_uniqueStorage()._link = nil}

    public var position: OneOf_Position? {
      get {return _storage._position}
      set {_uniqueStorage()._position = newValue}
    }

    public var commitPosition: UInt64 {
      get {
        if case .commitPosition(let v)? = _storage._position {return v}
        return 0
      }
      set {_uniqueStorage()._position = .commitPosition(newValue)}
    }

    public var noPosition: EventStore_Client_Empty {
      get {
        if case .noPosition(let v)? = _storage._position {return v}
        return EventStore_Client_Empty()
      }
      set {_uniqueStorage()._position = .noPosition(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Position: Equatable {
      case commitPosition(UInt64)
      case noPosition(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position, rhs: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.commitPosition, .commitPosition): return {
          guard case .commitPosition(let l) = lhs, case .commitPosition(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noPosition, .noPosition): return {
          guard case .noPosition(let l) = lhs, case .noPosition(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct RecordedEvent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: EventStore_Client_UUID {
        get {return _id ?? EventStore_Client_UUID()}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      public var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      public mutating func clearID() {self._id = nil}

      public var streamIdentifier: EventStore_Client_StreamIdentifier {
        get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
        set {_streamIdentifier = newValue}
      }
      /// Returns true if `streamIdentifier` has been explicitly set.
      public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
      /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
      public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

      public var streamRevision: UInt64 = 0

      public var preparePosition: UInt64 = 0

      public var commitPosition: UInt64 = 0

      public var metadata: Dictionary<String,String> = [:]

      public var customMetadata: Data = Data()

      public var data: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _id: EventStore_Client_UUID? = nil
      fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct SubscriptionConfirmation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriptionID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Checkpoint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct StreamNotFound {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public init() {}
}

public struct EventStore_Client_Streams_AppendReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: EventStore_Client_Streams_AppendReq.OneOf_Content? = nil

  public var options: EventStore_Client_Streams_AppendReq.Options {
    get {
      if case .options(let v)? = content {return v}
      return EventStore_Client_Streams_AppendReq.Options()
    }
    set {content = .options(newValue)}
  }

  public var proposedMessage: EventStore_Client_Streams_AppendReq.ProposedMessage {
    get {
      if case .proposedMessage(let v)? = content {return v}
      return EventStore_Client_Streams_AppendReq.ProposedMessage()
    }
    set {content = .proposedMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case options(EventStore_Client_Streams_AppendReq.Options)
    case proposedMessage(EventStore_Client_Streams_AppendReq.ProposedMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_AppendReq.OneOf_Content, rhs: EventStore_Client_Streams_AppendReq.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.options, .options): return {
        guard case .options(let l) = lhs, case .options(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proposedMessage, .proposedMessage): return {
        guard case .proposedMessage(let l) = lhs, case .proposedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var expectedStreamRevision: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision? = nil

    public var revision: UInt64 {
      get {
        if case .revision(let v)? = expectedStreamRevision {return v}
        return 0
      }
      set {expectedStreamRevision = .revision(newValue)}
    }

    public var noStream: EventStore_Client_Empty {
      get {
        if case .noStream(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .noStream(newValue)}
    }

    public var any: EventStore_Client_Empty {
      get {
        if case .any(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .any(newValue)}
    }

    public var streamExists: EventStore_Client_Empty {
      get {
        if case .streamExists(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .streamExists(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ExpectedStreamRevision: Equatable {
      case revision(UInt64)
      case noStream(EventStore_Client_Empty)
      case any(EventStore_Client_Empty)
      case streamExists(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.revision, .revision): return {
          guard case .revision(let l) = lhs, case .revision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.any, .any): return {
          guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.streamExists, .streamExists): return {
          guard case .streamExists(let l) = lhs, case .streamExists(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public struct ProposedMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: EventStore_Client_UUID {
      get {return _id ?? EventStore_Client_UUID()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var metadata: Dictionary<String,String> = [:]

    public var customMetadata: Data = Data()

    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: EventStore_Client_UUID? = nil
  }

  public init() {}
}

public struct EventStore_Client_Streams_AppendResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: EventStore_Client_Streams_AppendResp.OneOf_Result? = nil

  public var success: EventStore_Client_Streams_AppendResp.Success {
    get {
      if case .success(let v)? = result {return v}
      return EventStore_Client_Streams_AppendResp.Success()
    }
    set {result = .success(newValue)}
  }

  public var wrongExpectedVersion: EventStore_Client_Streams_AppendResp.WrongExpectedVersion {
    get {
      if case .wrongExpectedVersion(let v)? = result {return v}
      return EventStore_Client_Streams_AppendResp.WrongExpectedVersion()
    }
    set {result = .wrongExpectedVersion(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case success(EventStore_Client_Streams_AppendResp.Success)
    case wrongExpectedVersion(EventStore_Client_Streams_AppendResp.WrongExpectedVersion)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_AppendResp.OneOf_Result, rhs: EventStore_Client_Streams_AppendResp.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wrongExpectedVersion, .wrongExpectedVersion): return {
        guard case .wrongExpectedVersion(let l) = lhs, case .wrongExpectedVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Position {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currentRevisionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption? = nil

    public var currentRevision: UInt64 {
      get {
        if case .currentRevision(let v)? = currentRevisionOption {return v}
        return 0
      }
      set {currentRevisionOption = .currentRevision(newValue)}
    }

    public var noStream: EventStore_Client_Empty {
      get {
        if case .noStream(let v)? = currentRevisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {currentRevisionOption = .noStream(newValue)}
    }

    public var positionOption: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption? = nil

    public var position: EventStore_Client_Streams_AppendResp.Position {
      get {
        if case .position(let v)? = positionOption {return v}
        return EventStore_Client_Streams_AppendResp.Position()
      }
      set {positionOption = .position(newValue)}
    }

    public var noPosition: EventStore_Client_Empty {
      get {
        if case .noPosition(let v)? = positionOption {return v}
        return EventStore_Client_Empty()
      }
      set {positionOption = .noPosition(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_CurrentRevisionOption: Equatable {
      case currentRevision(UInt64)
      case noStream(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.currentRevision, .currentRevision): return {
          guard case .currentRevision(let l) = lhs, case .currentRevision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_PositionOption: Equatable {
      case position(EventStore_Client_Streams_AppendResp.Position)
      case noPosition(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption, rhs: EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.position, .position): return {
          guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noPosition, .noPosition): return {
          guard case .noPosition(let l) = lhs, case .noPosition(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct WrongExpectedVersion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currentRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060? = nil

    public var currentRevision2060: UInt64 {
      get {
        if case .currentRevision2060(let v)? = currentRevisionOption2060 {return v}
        return 0
      }
      set {currentRevisionOption2060 = .currentRevision2060(newValue)}
    }

    public var noStream2060: EventStore_Client_Empty {
      get {
        if case .noStream2060(let v)? = currentRevisionOption2060 {return v}
        return EventStore_Client_Empty()
      }
      set {currentRevisionOption2060 = .noStream2060(newValue)}
    }

    public var expectedRevisionOption2060: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060? = nil

    public var expectedRevision2060: UInt64 {
      get {
        if case .expectedRevision2060(let v)? = expectedRevisionOption2060 {return v}
        return 0
      }
      set {expectedRevisionOption2060 = .expectedRevision2060(newValue)}
    }

    public var any2060: EventStore_Client_Empty {
      get {
        if case .any2060(let v)? = expectedRevisionOption2060 {return v}
        return EventStore_Client_Empty()
      }
      set {expectedRevisionOption2060 = .any2060(newValue)}
    }

    public var streamExists2060: EventStore_Client_Empty {
      get {
        if case .streamExists2060(let v)? = expectedRevisionOption2060 {return v}
        return EventStore_Client_Empty()
      }
      set {expectedRevisionOption2060 = .streamExists2060(newValue)}
    }

    public var currentRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption? = nil

    public var currentRevision: UInt64 {
      get {
        if case .currentRevision(let v)? = currentRevisionOption {return v}
        return 0
      }
      set {currentRevisionOption = .currentRevision(newValue)}
    }

    public var currentNoStream: EventStore_Client_Empty {
      get {
        if case .currentNoStream(let v)? = currentRevisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {currentRevisionOption = .currentNoStream(newValue)}
    }

    public var expectedRevisionOption: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption? = nil

    public var expectedRevision: UInt64 {
      get {
        if case .expectedRevision(let v)? = expectedRevisionOption {return v}
        return 0
      }
      set {expectedRevisionOption = .expectedRevision(newValue)}
    }

    public var expectedAny: EventStore_Client_Empty {
      get {
        if case .expectedAny(let v)? = expectedRevisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {expectedRevisionOption = .expectedAny(newValue)}
    }

    public var expectedStreamExists: EventStore_Client_Empty {
      get {
        if case .expectedStreamExists(let v)? = expectedRevisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {expectedRevisionOption = .expectedStreamExists(newValue)}
    }

    public var expectedNoStream: EventStore_Client_Empty {
      get {
        if case .expectedNoStream(let v)? = expectedRevisionOption {return v}
        return EventStore_Client_Empty()
      }
      set {expectedRevisionOption = .expectedNoStream(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_CurrentRevisionOption2060: Equatable {
      case currentRevision2060(UInt64)
      case noStream2060(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.currentRevision2060, .currentRevision2060): return {
          guard case .currentRevision2060(let l) = lhs, case .currentRevision2060(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream2060, .noStream2060): return {
          guard case .noStream2060(let l) = lhs, case .noStream2060(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_ExpectedRevisionOption2060: Equatable {
      case expectedRevision2060(UInt64)
      case any2060(EventStore_Client_Empty)
      case streamExists2060(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.expectedRevision2060, .expectedRevision2060): return {
          guard case .expectedRevision2060(let l) = lhs, case .expectedRevision2060(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.any2060, .any2060): return {
          guard case .any2060(let l) = lhs, case .any2060(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.streamExists2060, .streamExists2060): return {
          guard case .streamExists2060(let l) = lhs, case .streamExists2060(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_CurrentRevisionOption: Equatable {
      case currentRevision(UInt64)
      case currentNoStream(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.currentRevision, .currentRevision): return {
          guard case .currentRevision(let l) = lhs, case .currentRevision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.currentNoStream, .currentNoStream): return {
          guard case .currentNoStream(let l) = lhs, case .currentNoStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_ExpectedRevisionOption: Equatable {
      case expectedRevision(UInt64)
      case expectedAny(EventStore_Client_Empty)
      case expectedStreamExists(EventStore_Client_Empty)
      case expectedNoStream(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.expectedRevision, .expectedRevision): return {
          guard case .expectedRevision(let l) = lhs, case .expectedRevision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.expectedAny, .expectedAny): return {
          guard case .expectedAny(let l) = lhs, case .expectedAny(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.expectedStreamExists, .expectedStreamExists): return {
          guard case .expectedStreamExists(let l) = lhs, case .expectedStreamExists(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.expectedNoStream, .expectedNoStream): return {
          guard case .expectedNoStream(let l) = lhs, case .expectedNoStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

public struct EventStore_Client_Streams_BatchAppendReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var correlationID: EventStore_Client_UUID {
    get {return _correlationID ?? EventStore_Client_UUID()}
    set {_correlationID = newValue}
  }
  /// Returns true if `correlationID` has been explicitly set.
  public var hasCorrelationID: Bool {return self._correlationID != nil}
  /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelationID() {self._correlationID = nil}

  public var options: EventStore_Client_Streams_BatchAppendReq.Options {
    get {return _options ?? EventStore_Client_Streams_BatchAppendReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var proposedMessages: [EventStore_Client_Streams_BatchAppendReq.ProposedMessage] = []

  public var isFinal: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var expectedStreamPosition: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition? = nil

    public var streamPosition: UInt64 {
      get {
        if case .streamPosition(let v)? = expectedStreamPosition {return v}
        return 0
      }
      set {expectedStreamPosition = .streamPosition(newValue)}
    }

    public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .noStream(let v)? = expectedStreamPosition {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {expectedStreamPosition = .noStream(newValue)}
    }

    public var any: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .any(let v)? = expectedStreamPosition {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {expectedStreamPosition = .any(newValue)}
    }

    public var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .streamExists(let v)? = expectedStreamPosition {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {expectedStreamPosition = .streamExists(newValue)}
    }

    public var deadlineOption: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption? = nil

    public var deadline21100: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {
        if case .deadline21100(let v)? = deadlineOption {return v}
        return SwiftProtobuf.Google_Protobuf_Timestamp()
      }
      set {deadlineOption = .deadline21100(newValue)}
    }

    public var deadline: SwiftProtobuf.Google_Protobuf_Duration {
      get {
        if case .deadline(let v)? = deadlineOption {return v}
        return SwiftProtobuf.Google_Protobuf_Duration()
      }
      set {deadlineOption = .deadline(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ExpectedStreamPosition: Equatable {
      case streamPosition(UInt64)
      case noStream(SwiftProtobuf.Google_Protobuf_Empty)
      case any(SwiftProtobuf.Google_Protobuf_Empty)
      case streamExists(SwiftProtobuf.Google_Protobuf_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition, rhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.streamPosition, .streamPosition): return {
          guard case .streamPosition(let l) = lhs, case .streamPosition(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.any, .any): return {
          guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.streamExists, .streamExists): return {
          guard case .streamExists(let l) = lhs, case .streamExists(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_DeadlineOption: Equatable {
      case deadline21100(SwiftProtobuf.Google_Protobuf_Timestamp)
      case deadline(SwiftProtobuf.Google_Protobuf_Duration)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption, rhs: EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.deadline21100, .deadline21100): return {
          guard case .deadline21100(let l) = lhs, case .deadline21100(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.deadline, .deadline): return {
          guard case .deadline(let l) = lhs, case .deadline(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public struct ProposedMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: EventStore_Client_UUID {
      get {return _id ?? EventStore_Client_UUID()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var metadata: Dictionary<String,String> = [:]

    public var customMetadata: Data = Data()

    public var data: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: EventStore_Client_UUID? = nil
  }

  public init() {}

  fileprivate var _correlationID: EventStore_Client_UUID? = nil
  fileprivate var _options: EventStore_Client_Streams_BatchAppendReq.Options? = nil
}

public struct EventStore_Client_Streams_BatchAppendResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var correlationID: EventStore_Client_UUID {
    get {return _correlationID ?? EventStore_Client_UUID()}
    set {_correlationID = newValue}
  }
  /// Returns true if `correlationID` has been explicitly set.
  public var hasCorrelationID: Bool {return self._correlationID != nil}
  /// Clears the value of `correlationID`. Subsequent reads from it will return its default value.
  public mutating func clearCorrelationID() {self._correlationID = nil}

  public var result: EventStore_Client_Streams_BatchAppendResp.OneOf_Result? = nil

  public var error: Google_Rpc_Status {
    get {
      if case .error(let v)? = result {return v}
      return Google_Rpc_Status()
    }
    set {result = .error(newValue)}
  }

  public var success: EventStore_Client_Streams_BatchAppendResp.Success {
    get {
      if case .success(let v)? = result {return v}
      return EventStore_Client_Streams_BatchAppendResp.Success()
    }
    set {result = .success(newValue)}
  }

  public var streamIdentifier: EventStore_Client_StreamIdentifier {
    get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
    set {_streamIdentifier = newValue}
  }
  /// Returns true if `streamIdentifier` has been explicitly set.
  public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
  /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

  public var expectedStreamPosition: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition? = nil

  public var streamPosition: UInt64 {
    get {
      if case .streamPosition(let v)? = expectedStreamPosition {return v}
      return 0
    }
    set {expectedStreamPosition = .streamPosition(newValue)}
  }

  public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .noStream(let v)? = expectedStreamPosition {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {expectedStreamPosition = .noStream(newValue)}
  }

  public var any: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .any(let v)? = expectedStreamPosition {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {expectedStreamPosition = .any(newValue)}
  }

  public var streamExists: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .streamExists(let v)? = expectedStreamPosition {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {expectedStreamPosition = .streamExists(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Result: Equatable {
    case error(Google_Rpc_Status)
    case success(EventStore_Client_Streams_BatchAppendResp.Success)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp.OneOf_Result, rhs: EventStore_Client_Streams_BatchAppendResp.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_ExpectedStreamPosition: Equatable {
    case streamPosition(UInt64)
    case noStream(SwiftProtobuf.Google_Protobuf_Empty)
    case any(SwiftProtobuf.Google_Protobuf_Empty)
    case streamExists(SwiftProtobuf.Google_Protobuf_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition, rhs: EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.streamPosition, .streamPosition): return {
        guard case .streamPosition(let l) = lhs, case .streamPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noStream, .noStream): return {
        guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamExists, .streamExists): return {
        guard case .streamExists(let l) = lhs, case .streamExists(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Success {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currentRevisionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption? = nil

    public var currentRevision: UInt64 {
      get {
        if case .currentRevision(let v)? = currentRevisionOption {return v}
        return 0
      }
      set {currentRevisionOption = .currentRevision(newValue)}
    }

    public var noStream: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .noStream(let v)? = currentRevisionOption {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {currentRevisionOption = .noStream(newValue)}
    }

    public var positionOption: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption? = nil

    public var position: EventStore_Client_AllStreamPosition {
      get {
        if case .position(let v)? = positionOption {return v}
        return EventStore_Client_AllStreamPosition()
      }
      set {positionOption = .position(newValue)}
    }

    public var noPosition: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .noPosition(let v)? = positionOption {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {positionOption = .noPosition(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_CurrentRevisionOption: Equatable {
      case currentRevision(UInt64)
      case noStream(SwiftProtobuf.Google_Protobuf_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption, rhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.currentRevision, .currentRevision): return {
          guard case .currentRevision(let l) = lhs, case .currentRevision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum OneOf_PositionOption: Equatable {
      case position(EventStore_Client_AllStreamPosition)
      case noPosition(SwiftProtobuf.Google_Protobuf_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption, rhs: EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.position, .position): return {
          guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noPosition, .noPosition): return {
          guard case .noPosition(let l) = lhs, case .noPosition(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _correlationID: EventStore_Client_UUID? = nil
  fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
}

public struct EventStore_Client_Streams_DeleteReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Streams_DeleteReq.Options {
    get {return _options ?? EventStore_Client_Streams_DeleteReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var expectedStreamRevision: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision? = nil

    public var revision: UInt64 {
      get {
        if case .revision(let v)? = expectedStreamRevision {return v}
        return 0
      }
      set {expectedStreamRevision = .revision(newValue)}
    }

    public var noStream: EventStore_Client_Empty {
      get {
        if case .noStream(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .noStream(newValue)}
    }

    public var any: EventStore_Client_Empty {
      get {
        if case .any(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .any(newValue)}
    }

    public var streamExists: EventStore_Client_Empty {
      get {
        if case .streamExists(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .streamExists(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ExpectedStreamRevision: Equatable {
      case revision(UInt64)
      case noStream(EventStore_Client_Empty)
      case any(EventStore_Client_Empty)
      case streamExists(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.revision, .revision): return {
          guard case .revision(let l) = lhs, case .revision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.any, .any): return {
          guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.streamExists, .streamExists): return {
          guard case .streamExists(let l) = lhs, case .streamExists(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Streams_DeleteReq.Options? = nil
}

public struct EventStore_Client_Streams_DeleteResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var positionOption: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption? = nil

  public var position: EventStore_Client_Streams_DeleteResp.Position {
    get {
      if case .position(let v)? = positionOption {return v}
      return EventStore_Client_Streams_DeleteResp.Position()
    }
    set {positionOption = .position(newValue)}
  }

  public var noPosition: EventStore_Client_Empty {
    get {
      if case .noPosition(let v)? = positionOption {return v}
      return EventStore_Client_Empty()
    }
    set {positionOption = .noPosition(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PositionOption: Equatable {
    case position(EventStore_Client_Streams_DeleteResp.Position)
    case noPosition(EventStore_Client_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption, rhs: EventStore_Client_Streams_DeleteResp.OneOf_PositionOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPosition, .noPosition): return {
        guard case .noPosition(let l) = lhs, case .noPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Position {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct EventStore_Client_Streams_TombstoneReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Streams_TombstoneReq.Options {
    get {return _options ?? EventStore_Client_Streams_TombstoneReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var streamIdentifier: EventStore_Client_StreamIdentifier {
      get {return _streamIdentifier ?? EventStore_Client_StreamIdentifier()}
      set {_streamIdentifier = newValue}
    }
    /// Returns true if `streamIdentifier` has been explicitly set.
    public var hasStreamIdentifier: Bool {return self._streamIdentifier != nil}
    /// Clears the value of `streamIdentifier`. Subsequent reads from it will return its default value.
    public mutating func clearStreamIdentifier() {self._streamIdentifier = nil}

    public var expectedStreamRevision: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision? = nil

    public var revision: UInt64 {
      get {
        if case .revision(let v)? = expectedStreamRevision {return v}
        return 0
      }
      set {expectedStreamRevision = .revision(newValue)}
    }

    public var noStream: EventStore_Client_Empty {
      get {
        if case .noStream(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .noStream(newValue)}
    }

    public var any: EventStore_Client_Empty {
      get {
        if case .any(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .any(newValue)}
    }

    public var streamExists: EventStore_Client_Empty {
      get {
        if case .streamExists(let v)? = expectedStreamRevision {return v}
        return EventStore_Client_Empty()
      }
      set {expectedStreamRevision = .streamExists(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ExpectedStreamRevision: Equatable {
      case revision(UInt64)
      case noStream(EventStore_Client_Empty)
      case any(EventStore_Client_Empty)
      case streamExists(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision, rhs: EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.revision, .revision): return {
          guard case .revision(let l) = lhs, case .revision(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noStream, .noStream): return {
          guard case .noStream(let l) = lhs, case .noStream(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.any, .any): return {
          guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.streamExists, .streamExists): return {
          guard case .streamExists(let l) = lhs, case .streamExists(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _streamIdentifier: EventStore_Client_StreamIdentifier? = nil
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Streams_TombstoneReq.Options? = nil
}

public struct EventStore_Client_Streams_TombstoneResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var positionOption: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption? = nil

  public var position: EventStore_Client_Streams_TombstoneResp.Position {
    get {
      if case .position(let v)? = positionOption {return v}
      return EventStore_Client_Streams_TombstoneResp.Position()
    }
    set {positionOption = .position(newValue)}
  }

  public var noPosition: EventStore_Client_Empty {
    get {
      if case .noPosition(let v)? = positionOption {return v}
      return EventStore_Client_Empty()
    }
    set {positionOption = .noPosition(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PositionOption: Equatable {
    case position(EventStore_Client_Streams_TombstoneResp.Position)
    case noPosition(EventStore_Client_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption, rhs: EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.position, .position): return {
        guard case .position(let l) = lhs, case .position(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noPosition, .noPosition): return {
        guard case .noPosition(let l) = lhs, case .noPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Position {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commitPosition: UInt64 = 0

    public var preparePosition: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension EventStore_Client_Streams_ReadReq: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.OneOf_StreamOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.OneOf_CountOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.OneOf_FilterOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.StreamOptions: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.StreamOptions.OneOf_RevisionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.AllOptions: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.AllOptions.OneOf_AllOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.Position: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.FilterOptions: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Filter: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.OneOf_Window: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.UUIDOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.UUIDOption.OneOf_Content: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadReq.Options.ControlOption: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.OneOf_Content: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.CaughtUp: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.FellBehind: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.ReadEvent: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.SubscriptionConfirmation: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.Checkpoint: @unchecked Sendable {}
extension EventStore_Client_Streams_ReadResp.StreamNotFound: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendReq: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendReq.OneOf_Content: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendReq.Options: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendReq.ProposedMessage: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.OneOf_Result: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.Position: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.Success: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.Success.OneOf_CurrentRevisionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.Success.OneOf_PositionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption2060: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption2060: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_CurrentRevisionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion.OneOf_ExpectedRevisionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendReq: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendReq.Options: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendReq.Options.OneOf_ExpectedStreamPosition: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendReq.Options.OneOf_DeadlineOption: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendReq.ProposedMessage: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp.OneOf_Result: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp.OneOf_ExpectedStreamPosition: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp.Success: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp.Success.OneOf_CurrentRevisionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_BatchAppendResp.Success.OneOf_PositionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteReq: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteReq.Options: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteResp: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteResp.OneOf_PositionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_DeleteResp.Position: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneReq: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneReq.Options: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneReq.Options.OneOf_ExpectedStreamRevision: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneResp: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneResp.OneOf_PositionOption: @unchecked Sendable {}
extension EventStore_Client_Streams_TombstoneResp.Position: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event_store.client.streams"

extension EventStore_Client_Streams_ReadReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq, rhs: EventStore_Client_Streams_ReadReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .same(proto: "all"),
    3: .standard(proto: "read_direction"),
    4: .standard(proto: "resolve_links"),
    5: .same(proto: "count"),
    6: .same(proto: "subscription"),
    7: .same(proto: "filter"),
    8: .standard(proto: "no_filter"),
    9: .standard(proto: "uuid_option"),
    10: .standard(proto: "control_option"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_ReadReq.Options.StreamOptions?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .stream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .stream(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Streams_ReadReq.Options.AllOptions?
        var hadOneofValue = false
        if let current = self.streamOption {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.streamOption = .all(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.readDirection) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resolveLinks) }()
      case 5: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.countOption != nil {try decoder.handleConflictingOneOf()}
          self.countOption = .count(v)
        }
      }()
      case 6: try {
        var v: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions?
        var hadOneofValue = false
        if let current = self.countOption {
          hadOneofValue = true
          if case .subscription(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.countOption = .subscription(v)
        }
      }()
      case 7: try {
        var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions?
        var hadOneofValue = false
        if let current = self.filterOption {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterOption = .filter(v)
        }
      }()
      case 8: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.filterOption {
          hadOneofValue = true
          if case .noFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterOption = .noFilter(v)
        }
      }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._uuidOption) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._controlOption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.streamOption {
    case .stream?: try {
      guard case .stream(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .all?: try {
      guard case .all(let v)? = self.streamOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.readDirection != .forwards {
      try visitor.visitSingularEnumField(value: self.readDirection, fieldNumber: 3)
    }
    if self.resolveLinks != false {
      try visitor.visitSingularBoolField(value: self.resolveLinks, fieldNumber: 4)
    }
    switch self.countOption {
    case .count?: try {
      guard case .count(let v)? = self.countOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }()
    case .subscription?: try {
      guard case .subscription(let v)? = self.countOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    switch self.filterOption {
    case .filter?: try {
      guard case .filter(let v)? = self.filterOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .noFilter?: try {
      guard case .noFilter(let v)? = self.filterOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try { if let v = self._uuidOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._controlOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options, rhs: EventStore_Client_Streams_ReadReq.Options) -> Bool {
    if lhs.streamOption != rhs.streamOption {return false}
    if lhs.readDirection != rhs.readDirection {return false}
    if lhs.resolveLinks != rhs.resolveLinks {return false}
    if lhs.countOption != rhs.countOption {return false}
    if lhs.filterOption != rhs.filterOption {return false}
    if lhs._uuidOption != rhs._uuidOption {return false}
    if lhs._controlOption != rhs._controlOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.ReadDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Forwards"),
    1: .same(proto: "Backwards"),
  ]
}

extension EventStore_Client_Streams_ReadReq.Options.StreamOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".StreamOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .same(proto: "start"),
    4: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.revisionOption != nil {try decoder.handleConflictingOneOf()}
          self.revisionOption = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .start(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.revisionOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.revisionOption = .end(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.revisionOption {
    case .revision?: try {
      guard case .revision(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .start?: try {
      guard case .start(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .end?: try {
      guard case .end(let v)? = self.revisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions, rhs: EventStore_Client_Streams_ReadReq.Options.StreamOptions) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.revisionOption != rhs.revisionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.AllOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".AllOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_ReadReq.Options.Position?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .position(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .start(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.allOption {
          hadOneofValue = true
          if case .end(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.allOption = .end(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.allOption {
    case .position?: try {
      guard case .position(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .start?: try {
      guard case .start(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .end?: try {
      guard case .end(let v)? = self.allOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.AllOptions, rhs: EventStore_Client_Streams_ReadReq.Options.AllOptions) -> Bool {
    if lhs.allOption != rhs.allOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".SubscriptionOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions, rhs: EventStore_Client_Streams_ReadReq.Options.SubscriptionOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.Position, rhs: EventStore_Client_Streams_ReadReq.Options.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".FilterOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .standard(proto: "event_type"),
    3: .same(proto: "max"),
    4: .same(proto: "count"),
    5: .same(proto: "checkpointIntervalMultiplier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .streamIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .streamIdentifier(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression?
        var hadOneofValue = false
        if let current = self.filter {
          hadOneofValue = true
          if case .eventType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filter = .eventType(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.window != nil {try decoder.handleConflictingOneOf()}
          self.window = .max(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.window {
          hadOneofValue = true
          if case .count(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.window = .count(v)
        }
      }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.checkpointIntervalMultiplier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filter {
    case .streamIdentifier?: try {
      guard case .streamIdentifier(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .eventType?: try {
      guard case .eventType(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.window {
    case .max?: try {
      guard case .max(let v)? = self.window else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .count?: try {
      guard case .count(let v)? = self.window else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.checkpointIntervalMultiplier != 0 {
      try visitor.visitSingularUInt32Field(value: self.checkpointIntervalMultiplier, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.window != rhs.window {return false}
    if lhs.checkpointIntervalMultiplier != rhs.checkpointIntervalMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.FilterOptions.protoMessageName + ".Expression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regex"),
    2: .same(proto: "prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regex) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.prefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regex.isEmpty {
      try visitor.visitSingularStringField(value: self.regex, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.prefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression, rhs: EventStore_Client_Streams_ReadReq.Options.FilterOptions.Expression) -> Bool {
    if lhs.regex != rhs.regex {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.UUIDOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".UUIDOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "structured"),
    2: .same(proto: "string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .structured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .structured(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .string(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .string(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .structured?: try {
      guard case .structured(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .string?: try {
      guard case .string(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption, rhs: EventStore_Client_Streams_ReadReq.Options.UUIDOption) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadReq.Options.ControlOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadReq.Options.protoMessageName + ".ControlOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "compatibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.compatibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.compatibility != 0 {
      try visitor.visitSingularUInt32Field(value: self.compatibility, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadReq.Options.ControlOption, rhs: EventStore_Client_Streams_ReadReq.Options.ControlOption) -> Bool {
    if lhs.compatibility != rhs.compatibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "confirmation"),
    3: .same(proto: "checkpoint"),
    4: .standard(proto: "stream_not_found"),
    5: .standard(proto: "first_stream_position"),
    6: .standard(proto: "last_stream_position"),
    7: .standard(proto: "last_all_stream_position"),
    8: .standard(proto: "caught_up"),
    9: .standard(proto: "fell_behind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_ReadResp.ReadEvent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .event(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .confirmation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .confirmation(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Streams_ReadResp.Checkpoint?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .checkpoint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .checkpoint(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Streams_ReadResp.StreamNotFound?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .streamNotFound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .streamNotFound(v)
        }
      }()
      case 5: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .firstStreamPosition(v)
        }
      }()
      case 6: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .lastStreamPosition(v)
        }
      }()
      case 7: try {
        var v: EventStore_Client_AllStreamPosition?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .lastAllStreamPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .lastAllStreamPosition(v)
        }
      }()
      case 8: try {
        var v: EventStore_Client_Streams_ReadResp.CaughtUp?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .caughtUp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .caughtUp(v)
        }
      }()
      case 9: try {
        var v: EventStore_Client_Streams_ReadResp.FellBehind?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .fellBehind(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .fellBehind(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .event?: try {
      guard case .event(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .confirmation?: try {
      guard case .confirmation(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .checkpoint?: try {
      guard case .checkpoint(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .streamNotFound?: try {
      guard case .streamNotFound(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .firstStreamPosition?: try {
      guard case .firstStreamPosition(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }()
    case .lastStreamPosition?: try {
      guard case .lastStreamPosition(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }()
    case .lastAllStreamPosition?: try {
      guard case .lastAllStreamPosition(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .caughtUp?: try {
      guard case .caughtUp(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .fellBehind?: try {
      guard case .fellBehind(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp, rhs: EventStore_Client_Streams_ReadResp) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.CaughtUp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".CaughtUp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.CaughtUp, rhs: EventStore_Client_Streams_ReadResp.CaughtUp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.FellBehind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".FellBehind"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.FellBehind, rhs: EventStore_Client_Streams_ReadResp.FellBehind) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".ReadEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "link"),
    3: .standard(proto: "commit_position"),
    4: .standard(proto: "no_position"),
  ]

  fileprivate class _StorageClass {
    var _event: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent? = nil
    var _link: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent? = nil
    var _position: EventStore_Client_Streams_ReadResp.ReadEvent.OneOf_Position?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _event = source._event
      _link = source._link
      _position = source._position
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._event) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._link) }()
        case 3: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._position != nil {try decoder.handleConflictingOneOf()}
            _storage._position = .commitPosition(v)
          }
        }()
        case 4: try {
          var v: EventStore_Client_Empty?
          var hadOneofValue = false
          if let current = _storage._position {
            hadOneofValue = true
            if case .noPosition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._position = .noPosition(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._event {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      switch _storage._position {
      case .commitPosition?: try {
        guard case .commitPosition(let v)? = _storage._position else { preconditionFailure() }
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }()
      case .noPosition?: try {
        guard case .noPosition(let v)? = _storage._position else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.ReadEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._event != rhs_storage._event {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._position != rhs_storage._position {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.ReadEvent.protoMessageName + ".RecordedEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "stream_identifier"),
    3: .standard(proto: "stream_revision"),
    4: .standard(proto: "prepare_position"),
    5: .standard(proto: "commit_position"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "custom_metadata"),
    8: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.streamRevision) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.customMetadata) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.streamRevision != 0 {
      try visitor.visitSingularUInt64Field(value: self.streamRevision, fieldNumber: 3)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 4)
    }
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 6)
    }
    if !self.customMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.customMetadata, fieldNumber: 7)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent, rhs: EventStore_Client_Streams_ReadResp.ReadEvent.RecordedEvent) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.streamRevision != rhs.streamRevision {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.customMetadata != rhs.customMetadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.SubscriptionConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".SubscriptionConfirmation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscriptionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriptionID.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation, rhs: EventStore_Client_Streams_ReadResp.SubscriptionConfirmation) -> Bool {
    if lhs.subscriptionID != rhs.subscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.Checkpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".Checkpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.Checkpoint, rhs: EventStore_Client_Streams_ReadResp.Checkpoint) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_ReadResp.StreamNotFound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_ReadResp.protoMessageName + ".StreamNotFound"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_ReadResp.StreamNotFound, rhs: EventStore_Client_Streams_ReadResp.StreamNotFound) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppendReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .standard(proto: "proposed_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_AppendReq.Options?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .options(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .options(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Streams_AppendReq.ProposedMessage?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .proposedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .proposedMessage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .options?: try {
      guard case .options(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .proposedMessage?: try {
      guard case .proposedMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendReq, rhs: EventStore_Client_Streams_AppendReq) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .standard(proto: "no_stream"),
    4: .same(proto: "any"),
    5: .standard(proto: "stream_exists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedStreamRevision != nil {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .noStream(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .any(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .any(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .streamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .streamExists(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.expectedStreamRevision {
    case .revision?: try {
      guard case .revision(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .any?: try {
      guard case .any(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .streamExists?: try {
      guard case .streamExists(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendReq.Options, rhs: EventStore_Client_Streams_AppendReq.Options) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.expectedStreamRevision != rhs.expectedStreamRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_AppendReq.protoMessageName + ".ProposedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "custom_metadata"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.customMetadata) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 2)
    }
    if !self.customMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.customMetadata, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendReq.ProposedMessage, rhs: EventStore_Client_Streams_AppendReq.ProposedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.customMetadata != rhs.customMetadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppendResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .standard(proto: "wrong_expected_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_AppendResp.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Streams_AppendResp.WrongExpectedVersion?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .wrongExpectedVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .wrongExpectedVersion(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wrongExpectedVersion?: try {
      guard case .wrongExpectedVersion(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendResp, rhs: EventStore_Client_Streams_AppendResp) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendResp.Position, rhs: EventStore_Client_Streams_AppendResp.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_revision"),
    2: .standard(proto: "no_stream"),
    3: .same(proto: "position"),
    4: .standard(proto: "no_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.currentRevisionOption != nil {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .currentRevision(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.currentRevisionOption {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .noStream(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Streams_AppendResp.Position?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .position(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .noPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .noPosition(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.currentRevisionOption {
    case .currentRevision?: try {
      guard case .currentRevision(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.positionOption {
    case .position?: try {
      guard case .position(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPosition?: try {
      guard case .noPosition(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendResp.Success, rhs: EventStore_Client_Streams_AppendResp.Success) -> Bool {
    if lhs.currentRevisionOption != rhs.currentRevisionOption {return false}
    if lhs.positionOption != rhs.positionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_AppendResp.WrongExpectedVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_AppendResp.protoMessageName + ".WrongExpectedVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_revision_20_6_0"),
    2: .standard(proto: "no_stream_20_6_0"),
    3: .standard(proto: "expected_revision_20_6_0"),
    4: .standard(proto: "any_20_6_0"),
    5: .standard(proto: "stream_exists_20_6_0"),
    6: .standard(proto: "current_revision"),
    7: .standard(proto: "current_no_stream"),
    8: .standard(proto: "expected_revision"),
    9: .standard(proto: "expected_any"),
    10: .standard(proto: "expected_stream_exists"),
    11: .standard(proto: "expected_no_stream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.currentRevisionOption2060 != nil {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption2060 = .currentRevision2060(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.currentRevisionOption2060 {
          hadOneofValue = true
          if case .noStream2060(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption2060 = .noStream2060(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedRevisionOption2060 != nil {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption2060 = .expectedRevision2060(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedRevisionOption2060 {
          hadOneofValue = true
          if case .any2060(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption2060 = .any2060(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedRevisionOption2060 {
          hadOneofValue = true
          if case .streamExists2060(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption2060 = .streamExists2060(v)
        }
      }()
      case 6: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.currentRevisionOption != nil {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .currentRevision(v)
        }
      }()
      case 7: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.currentRevisionOption {
          hadOneofValue = true
          if case .currentNoStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .currentNoStream(v)
        }
      }()
      case 8: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedRevisionOption != nil {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption = .expectedRevision(v)
        }
      }()
      case 9: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedRevisionOption {
          hadOneofValue = true
          if case .expectedAny(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption = .expectedAny(v)
        }
      }()
      case 10: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedRevisionOption {
          hadOneofValue = true
          if case .expectedStreamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption = .expectedStreamExists(v)
        }
      }()
      case 11: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedRevisionOption {
          hadOneofValue = true
          if case .expectedNoStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedRevisionOption = .expectedNoStream(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.currentRevisionOption2060 {
    case .currentRevision2060?: try {
      guard case .currentRevision2060(let v)? = self.currentRevisionOption2060 else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .noStream2060?: try {
      guard case .noStream2060(let v)? = self.currentRevisionOption2060 else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.expectedRevisionOption2060 {
    case .expectedRevision2060?: try {
      guard case .expectedRevision2060(let v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case .any2060?: try {
      guard case .any2060(let v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .streamExists2060?: try {
      guard case .streamExists2060(let v)? = self.expectedRevisionOption2060 else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    switch self.currentRevisionOption {
    case .currentRevision?: try {
      guard case .currentRevision(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }()
    case .currentNoStream?: try {
      guard case .currentNoStream(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    switch self.expectedRevisionOption {
    case .expectedRevision?: try {
      guard case .expectedRevision(let v)? = self.expectedRevisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    }()
    case .expectedAny?: try {
      guard case .expectedAny(let v)? = self.expectedRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .expectedStreamExists?: try {
      guard case .expectedStreamExists(let v)? = self.expectedRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .expectedNoStream?: try {
      guard case .expectedNoStream(let v)? = self.expectedRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion, rhs: EventStore_Client_Streams_AppendResp.WrongExpectedVersion) -> Bool {
    if lhs.currentRevisionOption2060 != rhs.currentRevisionOption2060 {return false}
    if lhs.expectedRevisionOption2060 != rhs.expectedRevisionOption2060 {return false}
    if lhs.currentRevisionOption != rhs.currentRevisionOption {return false}
    if lhs.expectedRevisionOption != rhs.expectedRevisionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_BatchAppendReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchAppendReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "correlation_id"),
    2: .same(proto: "options"),
    3: .standard(proto: "proposed_messages"),
    4: .standard(proto: "is_final"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._correlationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.proposedMessages) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isFinal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._correlationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.proposedMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposedMessages, fieldNumber: 3)
    }
    if self.isFinal != false {
      try visitor.visitSingularBoolField(value: self.isFinal, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_BatchAppendReq, rhs: EventStore_Client_Streams_BatchAppendReq) -> Bool {
    if lhs._correlationID != rhs._correlationID {return false}
    if lhs._options != rhs._options {return false}
    if lhs.proposedMessages != rhs.proposedMessages {return false}
    if lhs.isFinal != rhs.isFinal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_BatchAppendReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .standard(proto: "stream_position"),
    3: .standard(proto: "no_stream"),
    4: .same(proto: "any"),
    5: .standard(proto: "stream_exists"),
    6: .standard(proto: "deadline_21_10_0"),
    7: .same(proto: "deadline"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedStreamPosition != nil {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .streamPosition(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .noStream(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .any(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .any(v)
        }
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .streamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .streamExists(v)
        }
      }()
      case 6: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.deadlineOption {
          hadOneofValue = true
          if case .deadline21100(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deadlineOption = .deadline21100(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        var hadOneofValue = false
        if let current = self.deadlineOption {
          hadOneofValue = true
          if case .deadline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deadlineOption = .deadline(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.expectedStreamPosition {
    case .streamPosition?: try {
      guard case .streamPosition(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .any?: try {
      guard case .any(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .streamExists?: try {
      guard case .streamExists(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    switch self.deadlineOption {
    case .deadline21100?: try {
      guard case .deadline21100(let v)? = self.deadlineOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deadline?: try {
      guard case .deadline(let v)? = self.deadlineOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_BatchAppendReq.Options, rhs: EventStore_Client_Streams_BatchAppendReq.Options) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.expectedStreamPosition != rhs.expectedStreamPosition {return false}
    if lhs.deadlineOption != rhs.deadlineOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_BatchAppendReq.ProposedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendReq.protoMessageName + ".ProposedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "custom_metadata"),
    4: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.customMetadata) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 2)
    }
    if !self.customMetadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.customMetadata, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage, rhs: EventStore_Client_Streams_BatchAppendReq.ProposedMessage) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.customMetadata != rhs.customMetadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_BatchAppendResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchAppendResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "correlation_id"),
    2: .same(proto: "error"),
    3: .same(proto: "success"),
    4: .standard(proto: "stream_identifier"),
    5: .standard(proto: "stream_position"),
    6: .standard(proto: "no_stream"),
    7: .same(proto: "any"),
    8: .standard(proto: "stream_exists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._correlationID) }()
      case 2: try {
        var v: Google_Rpc_Status?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .error(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Streams_BatchAppendResp.Success?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .success(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 5: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedStreamPosition != nil {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .streamPosition(v)
        }
      }()
      case 6: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .noStream(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .any(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .any(v)
        }
      }()
      case 8: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamPosition {
          hadOneofValue = true
          if case .streamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamPosition = .streamExists(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._correlationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.result {
    case .error?: try {
      guard case .error(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.expectedStreamPosition {
    case .streamPosition?: try {
      guard case .streamPosition(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .any?: try {
      guard case .any(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .streamExists?: try {
      guard case .streamExists(let v)? = self.expectedStreamPosition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp, rhs: EventStore_Client_Streams_BatchAppendResp) -> Bool {
    if lhs._correlationID != rhs._correlationID {return false}
    if lhs.result != rhs.result {return false}
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.expectedStreamPosition != rhs.expectedStreamPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_BatchAppendResp.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_BatchAppendResp.protoMessageName + ".Success"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_revision"),
    2: .standard(proto: "no_stream"),
    3: .same(proto: "position"),
    4: .standard(proto: "no_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.currentRevisionOption != nil {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .currentRevision(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.currentRevisionOption {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.currentRevisionOption = .noStream(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_AllStreamPosition?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .position(v)
        }
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .noPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .noPosition(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.currentRevisionOption {
    case .currentRevision?: try {
      guard case .currentRevision(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.currentRevisionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    switch self.positionOption {
    case .position?: try {
      guard case .position(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .noPosition?: try {
      guard case .noPosition(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_BatchAppendResp.Success, rhs: EventStore_Client_Streams_BatchAppendResp.Success) -> Bool {
    if lhs.currentRevisionOption != rhs.currentRevisionOption {return false}
    if lhs.positionOption != rhs.positionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_DeleteReq, rhs: EventStore_Client_Streams_DeleteReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_DeleteReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .standard(proto: "no_stream"),
    4: .same(proto: "any"),
    5: .standard(proto: "stream_exists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedStreamRevision != nil {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .noStream(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .any(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .any(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .streamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .streamExists(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.expectedStreamRevision {
    case .revision?: try {
      guard case .revision(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .any?: try {
      guard case .any(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .streamExists?: try {
      guard case .streamExists(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_DeleteReq.Options, rhs: EventStore_Client_Streams_DeleteReq.Options) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.expectedStreamRevision != rhs.expectedStreamRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "no_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_DeleteResp.Position?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .position(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .noPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .noPosition(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.positionOption {
    case .position?: try {
      guard case .position(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .noPosition?: try {
      guard case .noPosition(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_DeleteResp, rhs: EventStore_Client_Streams_DeleteResp) -> Bool {
    if lhs.positionOption != rhs.positionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_DeleteResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_DeleteResp.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_DeleteResp.Position, rhs: EventStore_Client_Streams_DeleteResp.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_TombstoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TombstoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_TombstoneReq, rhs: EventStore_Client_Streams_TombstoneReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_TombstoneReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_TombstoneReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_identifier"),
    2: .same(proto: "revision"),
    3: .standard(proto: "no_stream"),
    4: .same(proto: "any"),
    5: .standard(proto: "stream_exists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streamIdentifier) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.expectedStreamRevision != nil {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .revision(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .noStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .noStream(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .any(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .any(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.expectedStreamRevision {
          hadOneofValue = true
          if case .streamExists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.expectedStreamRevision = .streamExists(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.expectedStreamRevision {
    case .revision?: try {
      guard case .revision(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .noStream?: try {
      guard case .noStream(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .any?: try {
      guard case .any(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .streamExists?: try {
      guard case .streamExists(let v)? = self.expectedStreamRevision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_TombstoneReq.Options, rhs: EventStore_Client_Streams_TombstoneReq.Options) -> Bool {
    if lhs._streamIdentifier != rhs._streamIdentifier {return false}
    if lhs.expectedStreamRevision != rhs.expectedStreamRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_TombstoneResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TombstoneResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "no_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Streams_TombstoneResp.Position?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .position(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .position(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.positionOption {
          hadOneofValue = true
          if case .noPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.positionOption = .noPosition(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.positionOption {
    case .position?: try {
      guard case .position(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .noPosition?: try {
      guard case .noPosition(let v)? = self.positionOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_TombstoneResp, rhs: EventStore_Client_Streams_TombstoneResp) -> Bool {
    if lhs.positionOption != rhs.positionOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Streams_TombstoneResp.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Streams_TombstoneResp.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_position"),
    2: .standard(proto: "prepare_position"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.commitPosition) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.preparePosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commitPosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.commitPosition, fieldNumber: 1)
    }
    if self.preparePosition != 0 {
      try visitor.visitSingularUInt64Field(value: self.preparePosition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Streams_TombstoneResp.Position, rhs: EventStore_Client_Streams_TombstoneResp.Position) -> Bool {
    if lhs.commitPosition != rhs.commitPosition {return false}
    if lhs.preparePosition != rhs.preparePosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
