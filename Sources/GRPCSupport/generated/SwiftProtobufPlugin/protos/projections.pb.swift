// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/projections.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct EventStore_Client_Projections_CreateReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_CreateReq.Options {
    get {return _options ?? EventStore_Client_Projections_CreateReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mode: EventStore_Client_Projections_CreateReq.Options.OneOf_Mode? = nil

    public var oneTime: EventStore_Client_Empty {
      get {
        if case .oneTime(let v)? = mode {return v}
        return EventStore_Client_Empty()
      }
      set {mode = .oneTime(newValue)}
    }

    public var transient: EventStore_Client_Projections_CreateReq.Options.Transient {
      get {
        if case .transient(let v)? = mode {return v}
        return EventStore_Client_Projections_CreateReq.Options.Transient()
      }
      set {mode = .transient(newValue)}
    }

    public var continuous: EventStore_Client_Projections_CreateReq.Options.Continuous {
      get {
        if case .continuous(let v)? = mode {return v}
        return EventStore_Client_Projections_CreateReq.Options.Continuous()
      }
      set {mode = .continuous(newValue)}
    }

    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Mode: Equatable {
      case oneTime(EventStore_Client_Empty)
      case transient(EventStore_Client_Projections_CreateReq.Options.Transient)
      case continuous(EventStore_Client_Projections_CreateReq.Options.Continuous)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Projections_CreateReq.Options.OneOf_Mode, rhs: EventStore_Client_Projections_CreateReq.Options.OneOf_Mode) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.oneTime, .oneTime): return {
          guard case .oneTime(let l) = lhs, case .oneTime(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.transient, .transient): return {
          guard case .transient(let l) = lhs, case .transient(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.continuous, .continuous): return {
          guard case .continuous(let l) = lhs, case .continuous(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct Transient {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Continuous {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var emitEnabled: Bool = false

      public var trackEmittedStreams: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_CreateReq.Options? = nil
}

public struct EventStore_Client_Projections_CreateResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_Projections_UpdateReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_UpdateReq.Options {
    get {return _options ?? EventStore_Client_Projections_UpdateReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var query: String = String()

    public var emitOption: EventStore_Client_Projections_UpdateReq.Options.OneOf_EmitOption? = nil

    public var emitEnabled: Bool {
      get {
        if case .emitEnabled(let v)? = emitOption {return v}
        return false
      }
      set {emitOption = .emitEnabled(newValue)}
    }

    public var noEmitOptions: EventStore_Client_Empty {
      get {
        if case .noEmitOptions(let v)? = emitOption {return v}
        return EventStore_Client_Empty()
      }
      set {emitOption = .noEmitOptions(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_EmitOption: Equatable {
      case emitEnabled(Bool)
      case noEmitOptions(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Projections_UpdateReq.Options.OneOf_EmitOption, rhs: EventStore_Client_Projections_UpdateReq.Options.OneOf_EmitOption) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.emitEnabled, .emitEnabled): return {
          guard case .emitEnabled(let l) = lhs, case .emitEnabled(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.noEmitOptions, .noEmitOptions): return {
          guard case .noEmitOptions(let l) = lhs, case .noEmitOptions(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_UpdateReq.Options? = nil
}

public struct EventStore_Client_Projections_UpdateResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_Projections_DeleteReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_DeleteReq.Options {
    get {return _options ?? EventStore_Client_Projections_DeleteReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var deleteEmittedStreams: Bool = false

    public var deleteStateStream: Bool = false

    public var deleteCheckpointStream: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_DeleteReq.Options? = nil
}

public struct EventStore_Client_Projections_DeleteResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_Projections_StatisticsReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_StatisticsReq.Options {
    get {return _options ?? EventStore_Client_Projections_StatisticsReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mode: EventStore_Client_Projections_StatisticsReq.Options.OneOf_Mode? = nil

    public var name: String {
      get {
        if case .name(let v)? = mode {return v}
        return String()
      }
      set {mode = .name(newValue)}
    }

    public var all: EventStore_Client_Empty {
      get {
        if case .all(let v)? = mode {return v}
        return EventStore_Client_Empty()
      }
      set {mode = .all(newValue)}
    }

    public var transient: EventStore_Client_Empty {
      get {
        if case .transient(let v)? = mode {return v}
        return EventStore_Client_Empty()
      }
      set {mode = .transient(newValue)}
    }

    public var continuous: EventStore_Client_Empty {
      get {
        if case .continuous(let v)? = mode {return v}
        return EventStore_Client_Empty()
      }
      set {mode = .continuous(newValue)}
    }

    public var oneTime: EventStore_Client_Empty {
      get {
        if case .oneTime(let v)? = mode {return v}
        return EventStore_Client_Empty()
      }
      set {mode = .oneTime(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Mode: Equatable {
      case name(String)
      case all(EventStore_Client_Empty)
      case transient(EventStore_Client_Empty)
      case continuous(EventStore_Client_Empty)
      case oneTime(EventStore_Client_Empty)

    #if !swift(>=4.1)
      public static func ==(lhs: EventStore_Client_Projections_StatisticsReq.Options.OneOf_Mode, rhs: EventStore_Client_Projections_StatisticsReq.Options.OneOf_Mode) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.name, .name): return {
          guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.all, .all): return {
          guard case .all(let l) = lhs, case .all(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.transient, .transient): return {
          guard case .transient(let l) = lhs, case .transient(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.continuous, .continuous): return {
          guard case .continuous(let l) = lhs, case .continuous(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.oneTime, .oneTime): return {
          guard case .oneTime(let l) = lhs, case .oneTime(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_StatisticsReq.Options? = nil
}

public struct EventStore_Client_Projections_StatisticsResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var details: EventStore_Client_Projections_StatisticsResp.Details {
    get {return _details ?? EventStore_Client_Projections_StatisticsResp.Details()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  public var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  public mutating func clearDetails() {self._details = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Details {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var coreProcessingTime: Int64 {
      get {return _storage._coreProcessingTime}
      set {_uniqueStorage()._coreProcessingTime = newValue}
    }

    public var version: Int64 {
      get {return _storage._version}
      set {_uniqueStorage()._version = newValue}
    }

    public var epoch: Int64 {
      get {return _storage._epoch}
      set {_uniqueStorage()._epoch = newValue}
    }

    public var effectiveName: String {
      get {return _storage._effectiveName}
      set {_uniqueStorage()._effectiveName = newValue}
    }

    public var writesInProgress: Int32 {
      get {return _storage._writesInProgress}
      set {_uniqueStorage()._writesInProgress = newValue}
    }

    public var readsInProgress: Int32 {
      get {return _storage._readsInProgress}
      set {_uniqueStorage()._readsInProgress = newValue}
    }

    public var partitionsCached: Int32 {
      get {return _storage._partitionsCached}
      set {_uniqueStorage()._partitionsCached = newValue}
    }

    public var status: String {
      get {return _storage._status}
      set {_uniqueStorage()._status = newValue}
    }

    public var stateReason: String {
      get {return _storage._stateReason}
      set {_uniqueStorage()._stateReason = newValue}
    }

    public var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    public var mode: String {
      get {return _storage._mode}
      set {_uniqueStorage()._mode = newValue}
    }

    public var position: String {
      get {return _storage._position}
      set {_uniqueStorage()._position = newValue}
    }

    public var progress: Float {
      get {return _storage._progress}
      set {_uniqueStorage()._progress = newValue}
    }

    public var lastCheckpoint: String {
      get {return _storage._lastCheckpoint}
      set {_uniqueStorage()._lastCheckpoint = newValue}
    }

    public var eventsProcessedAfterRestart: Int64 {
      get {return _storage._eventsProcessedAfterRestart}
      set {_uniqueStorage()._eventsProcessedAfterRestart = newValue}
    }

    public var checkpointStatus: String {
      get {return _storage._checkpointStatus}
      set {_uniqueStorage()._checkpointStatus = newValue}
    }

    public var bufferedEvents: Int64 {
      get {return _storage._bufferedEvents}
      set {_uniqueStorage()._bufferedEvents = newValue}
    }

    public var writePendingEventsBeforeCheckpoint: Int32 {
      get {return _storage._writePendingEventsBeforeCheckpoint}
      set {_uniqueStorage()._writePendingEventsBeforeCheckpoint = newValue}
    }

    public var writePendingEventsAfterCheckpoint: Int32 {
      get {return _storage._writePendingEventsAfterCheckpoint}
      set {_uniqueStorage()._writePendingEventsAfterCheckpoint = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _details: EventStore_Client_Projections_StatisticsResp.Details? = nil
}

public struct EventStore_Client_Projections_StateReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_StateReq.Options {
    get {return _options ?? EventStore_Client_Projections_StateReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var partition: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_StateReq.Options? = nil
}

public struct EventStore_Client_Projections_StateResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var state: SwiftProtobuf.Google_Protobuf_Value {
    get {return _state ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: SwiftProtobuf.Google_Protobuf_Value? = nil
}

public struct EventStore_Client_Projections_ResultReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_ResultReq.Options {
    get {return _options ?? EventStore_Client_Projections_ResultReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var partition: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_ResultReq.Options? = nil
}

public struct EventStore_Client_Projections_ResultResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: SwiftProtobuf.Google_Protobuf_Value {
    get {return _result ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: SwiftProtobuf.Google_Protobuf_Value? = nil
}

public struct EventStore_Client_Projections_ResetReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_ResetReq.Options {
    get {return _options ?? EventStore_Client_Projections_ResetReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var writeCheckpoint: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_ResetReq.Options? = nil
}

public struct EventStore_Client_Projections_ResetResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_Projections_EnableReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_EnableReq.Options {
    get {return _options ?? EventStore_Client_Projections_EnableReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_EnableReq.Options? = nil
}

public struct EventStore_Client_Projections_EnableResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct EventStore_Client_Projections_DisableReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var options: EventStore_Client_Projections_DisableReq.Options {
    get {return _options ?? EventStore_Client_Projections_DisableReq.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var writeCheckpoint: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _options: EventStore_Client_Projections_DisableReq.Options? = nil
}

public struct EventStore_Client_Projections_DisableResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension EventStore_Client_Projections_CreateReq: @unchecked Sendable {}
extension EventStore_Client_Projections_CreateReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_CreateReq.Options.OneOf_Mode: @unchecked Sendable {}
extension EventStore_Client_Projections_CreateReq.Options.Transient: @unchecked Sendable {}
extension EventStore_Client_Projections_CreateReq.Options.Continuous: @unchecked Sendable {}
extension EventStore_Client_Projections_CreateResp: @unchecked Sendable {}
extension EventStore_Client_Projections_UpdateReq: @unchecked Sendable {}
extension EventStore_Client_Projections_UpdateReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_UpdateReq.Options.OneOf_EmitOption: @unchecked Sendable {}
extension EventStore_Client_Projections_UpdateResp: @unchecked Sendable {}
extension EventStore_Client_Projections_DeleteReq: @unchecked Sendable {}
extension EventStore_Client_Projections_DeleteReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_DeleteResp: @unchecked Sendable {}
extension EventStore_Client_Projections_StatisticsReq: @unchecked Sendable {}
extension EventStore_Client_Projections_StatisticsReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_StatisticsReq.Options.OneOf_Mode: @unchecked Sendable {}
extension EventStore_Client_Projections_StatisticsResp: @unchecked Sendable {}
extension EventStore_Client_Projections_StatisticsResp.Details: @unchecked Sendable {}
extension EventStore_Client_Projections_StateReq: @unchecked Sendable {}
extension EventStore_Client_Projections_StateReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_StateResp: @unchecked Sendable {}
extension EventStore_Client_Projections_ResultReq: @unchecked Sendable {}
extension EventStore_Client_Projections_ResultReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_ResultResp: @unchecked Sendable {}
extension EventStore_Client_Projections_ResetReq: @unchecked Sendable {}
extension EventStore_Client_Projections_ResetReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_ResetResp: @unchecked Sendable {}
extension EventStore_Client_Projections_EnableReq: @unchecked Sendable {}
extension EventStore_Client_Projections_EnableReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_EnableResp: @unchecked Sendable {}
extension EventStore_Client_Projections_DisableReq: @unchecked Sendable {}
extension EventStore_Client_Projections_DisableReq.Options: @unchecked Sendable {}
extension EventStore_Client_Projections_DisableResp: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "event_store.client.projections"

extension EventStore_Client_Projections_CreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_CreateReq, rhs: EventStore_Client_Projections_CreateReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_CreateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_CreateReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "one_time"),
    2: .same(proto: "transient"),
    3: .same(proto: "continuous"),
    4: .same(proto: "query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .oneTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .oneTime(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Projections_CreateReq.Options.Transient?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .transient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .transient(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Projections_CreateReq.Options.Continuous?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .continuous(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .continuous(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .oneTime?: try {
      guard case .oneTime(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transient?: try {
      guard case .transient(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .continuous?: try {
      guard case .continuous(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_CreateReq.Options, rhs: EventStore_Client_Projections_CreateReq.Options) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_CreateReq.Options.Transient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_CreateReq.Options.protoMessageName + ".Transient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_CreateReq.Options.Transient, rhs: EventStore_Client_Projections_CreateReq.Options.Transient) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_CreateReq.Options.Continuous: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_CreateReq.Options.protoMessageName + ".Continuous"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "emit_enabled"),
    3: .standard(proto: "track_emitted_streams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.emitEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trackEmittedStreams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.emitEnabled != false {
      try visitor.visitSingularBoolField(value: self.emitEnabled, fieldNumber: 2)
    }
    if self.trackEmittedStreams != false {
      try visitor.visitSingularBoolField(value: self.trackEmittedStreams, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_CreateReq.Options.Continuous, rhs: EventStore_Client_Projections_CreateReq.Options.Continuous) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.emitEnabled != rhs.emitEnabled {return false}
    if lhs.trackEmittedStreams != rhs.trackEmittedStreams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_CreateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_CreateResp, rhs: EventStore_Client_Projections_CreateResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_UpdateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_UpdateReq, rhs: EventStore_Client_Projections_UpdateReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_UpdateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_UpdateReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "query"),
    3: .standard(proto: "emit_enabled"),
    4: .standard(proto: "no_emit_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.emitOption != nil {try decoder.handleConflictingOneOf()}
          self.emitOption = .emitEnabled(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.emitOption {
          hadOneofValue = true
          if case .noEmitOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.emitOption = .noEmitOptions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    switch self.emitOption {
    case .emitEnabled?: try {
      guard case .emitEnabled(let v)? = self.emitOption else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .noEmitOptions?: try {
      guard case .noEmitOptions(let v)? = self.emitOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_UpdateReq.Options, rhs: EventStore_Client_Projections_UpdateReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.query != rhs.query {return false}
    if lhs.emitOption != rhs.emitOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_UpdateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_UpdateResp, rhs: EventStore_Client_Projections_UpdateResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DeleteReq, rhs: EventStore_Client_Projections_DeleteReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DeleteReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_DeleteReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "delete_emitted_streams"),
    3: .standard(proto: "delete_state_stream"),
    4: .standard(proto: "delete_checkpoint_stream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleteEmittedStreams) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleteStateStream) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.deleteCheckpointStream) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.deleteEmittedStreams != false {
      try visitor.visitSingularBoolField(value: self.deleteEmittedStreams, fieldNumber: 2)
    }
    if self.deleteStateStream != false {
      try visitor.visitSingularBoolField(value: self.deleteStateStream, fieldNumber: 3)
    }
    if self.deleteCheckpointStream != false {
      try visitor.visitSingularBoolField(value: self.deleteCheckpointStream, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DeleteReq.Options, rhs: EventStore_Client_Projections_DeleteReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.deleteEmittedStreams != rhs.deleteEmittedStreams {return false}
    if lhs.deleteStateStream != rhs.deleteStateStream {return false}
    if lhs.deleteCheckpointStream != rhs.deleteCheckpointStream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DeleteResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DeleteResp, rhs: EventStore_Client_Projections_DeleteResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StatisticsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StatisticsReq, rhs: EventStore_Client_Projections_StatisticsReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StatisticsReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_StatisticsReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "all"),
    3: .same(proto: "transient"),
    4: .same(proto: "continuous"),
    5: .standard(proto: "one_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.mode != nil {try decoder.handleConflictingOneOf()}
          self.mode = .name(v)
        }
      }()
      case 2: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .all(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .all(v)
        }
      }()
      case 3: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .transient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .transient(v)
        }
      }()
      case 4: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .continuous(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .continuous(v)
        }
      }()
      case 5: try {
        var v: EventStore_Client_Empty?
        var hadOneofValue = false
        if let current = self.mode {
          hadOneofValue = true
          if case .oneTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.mode = .oneTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.mode {
    case .name?: try {
      guard case .name(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .all?: try {
      guard case .all(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .transient?: try {
      guard case .transient(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .continuous?: try {
      guard case .continuous(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .oneTime?: try {
      guard case .oneTime(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StatisticsReq.Options, rhs: EventStore_Client_Projections_StatisticsReq.Options) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StatisticsResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatisticsResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StatisticsResp, rhs: EventStore_Client_Projections_StatisticsResp) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StatisticsResp.Details: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_StatisticsResp.protoMessageName + ".Details"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coreProcessingTime"),
    2: .same(proto: "version"),
    3: .same(proto: "epoch"),
    4: .same(proto: "effectiveName"),
    5: .same(proto: "writesInProgress"),
    6: .same(proto: "readsInProgress"),
    7: .same(proto: "partitionsCached"),
    8: .same(proto: "status"),
    9: .same(proto: "stateReason"),
    10: .same(proto: "name"),
    11: .same(proto: "mode"),
    12: .same(proto: "position"),
    13: .same(proto: "progress"),
    14: .same(proto: "lastCheckpoint"),
    15: .same(proto: "eventsProcessedAfterRestart"),
    16: .same(proto: "checkpointStatus"),
    17: .same(proto: "bufferedEvents"),
    18: .same(proto: "writePendingEventsBeforeCheckpoint"),
    19: .same(proto: "writePendingEventsAfterCheckpoint"),
  ]

  fileprivate class _StorageClass {
    var _coreProcessingTime: Int64 = 0
    var _version: Int64 = 0
    var _epoch: Int64 = 0
    var _effectiveName: String = String()
    var _writesInProgress: Int32 = 0
    var _readsInProgress: Int32 = 0
    var _partitionsCached: Int32 = 0
    var _status: String = String()
    var _stateReason: String = String()
    var _name: String = String()
    var _mode: String = String()
    var _position: String = String()
    var _progress: Float = 0
    var _lastCheckpoint: String = String()
    var _eventsProcessedAfterRestart: Int64 = 0
    var _checkpointStatus: String = String()
    var _bufferedEvents: Int64 = 0
    var _writePendingEventsBeforeCheckpoint: Int32 = 0
    var _writePendingEventsAfterCheckpoint: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _coreProcessingTime = source._coreProcessingTime
      _version = source._version
      _epoch = source._epoch
      _effectiveName = source._effectiveName
      _writesInProgress = source._writesInProgress
      _readsInProgress = source._readsInProgress
      _partitionsCached = source._partitionsCached
      _status = source._status
      _stateReason = source._stateReason
      _name = source._name
      _mode = source._mode
      _position = source._position
      _progress = source._progress
      _lastCheckpoint = source._lastCheckpoint
      _eventsProcessedAfterRestart = source._eventsProcessedAfterRestart
      _checkpointStatus = source._checkpointStatus
      _bufferedEvents = source._bufferedEvents
      _writePendingEventsBeforeCheckpoint = source._writePendingEventsBeforeCheckpoint
      _writePendingEventsAfterCheckpoint = source._writePendingEventsAfterCheckpoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._coreProcessingTime) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._version) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._epoch) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._effectiveName) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._writesInProgress) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._readsInProgress) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._partitionsCached) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._stateReason) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._mode) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._position) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._progress) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._lastCheckpoint) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._eventsProcessedAfterRestart) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._checkpointStatus) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._bufferedEvents) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._writePendingEventsBeforeCheckpoint) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._writePendingEventsAfterCheckpoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._coreProcessingTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._coreProcessingTime, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt64Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._epoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._epoch, fieldNumber: 3)
      }
      if !_storage._effectiveName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._effectiveName, fieldNumber: 4)
      }
      if _storage._writesInProgress != 0 {
        try visitor.visitSingularInt32Field(value: _storage._writesInProgress, fieldNumber: 5)
      }
      if _storage._readsInProgress != 0 {
        try visitor.visitSingularInt32Field(value: _storage._readsInProgress, fieldNumber: 6)
      }
      if _storage._partitionsCached != 0 {
        try visitor.visitSingularInt32Field(value: _storage._partitionsCached, fieldNumber: 7)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 8)
      }
      if !_storage._stateReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateReason, fieldNumber: 9)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 10)
      }
      if !_storage._mode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mode, fieldNumber: 11)
      }
      if !_storage._position.isEmpty {
        try visitor.visitSingularStringField(value: _storage._position, fieldNumber: 12)
      }
      if _storage._progress != 0 {
        try visitor.visitSingularFloatField(value: _storage._progress, fieldNumber: 13)
      }
      if !_storage._lastCheckpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastCheckpoint, fieldNumber: 14)
      }
      if _storage._eventsProcessedAfterRestart != 0 {
        try visitor.visitSingularInt64Field(value: _storage._eventsProcessedAfterRestart, fieldNumber: 15)
      }
      if !_storage._checkpointStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checkpointStatus, fieldNumber: 16)
      }
      if _storage._bufferedEvents != 0 {
        try visitor.visitSingularInt64Field(value: _storage._bufferedEvents, fieldNumber: 17)
      }
      if _storage._writePendingEventsBeforeCheckpoint != 0 {
        try visitor.visitSingularInt32Field(value: _storage._writePendingEventsBeforeCheckpoint, fieldNumber: 18)
      }
      if _storage._writePendingEventsAfterCheckpoint != 0 {
        try visitor.visitSingularInt32Field(value: _storage._writePendingEventsAfterCheckpoint, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StatisticsResp.Details, rhs: EventStore_Client_Projections_StatisticsResp.Details) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coreProcessingTime != rhs_storage._coreProcessingTime {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._epoch != rhs_storage._epoch {return false}
        if _storage._effectiveName != rhs_storage._effectiveName {return false}
        if _storage._writesInProgress != rhs_storage._writesInProgress {return false}
        if _storage._readsInProgress != rhs_storage._readsInProgress {return false}
        if _storage._partitionsCached != rhs_storage._partitionsCached {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._stateReason != rhs_storage._stateReason {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._lastCheckpoint != rhs_storage._lastCheckpoint {return false}
        if _storage._eventsProcessedAfterRestart != rhs_storage._eventsProcessedAfterRestart {return false}
        if _storage._checkpointStatus != rhs_storage._checkpointStatus {return false}
        if _storage._bufferedEvents != rhs_storage._bufferedEvents {return false}
        if _storage._writePendingEventsBeforeCheckpoint != rhs_storage._writePendingEventsBeforeCheckpoint {return false}
        if _storage._writePendingEventsAfterCheckpoint != rhs_storage._writePendingEventsAfterCheckpoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StateReq, rhs: EventStore_Client_Projections_StateReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StateReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_StateReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "partition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.partition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.partition.isEmpty {
      try visitor.visitSingularStringField(value: self.partition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StateReq.Options, rhs: EventStore_Client_Projections_StateReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.partition != rhs.partition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_StateResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_StateResp, rhs: EventStore_Client_Projections_StateResp) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResultReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResultReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResultReq, rhs: EventStore_Client_Projections_ResultReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResultReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_ResultReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "partition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.partition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.partition.isEmpty {
      try visitor.visitSingularStringField(value: self.partition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResultReq.Options, rhs: EventStore_Client_Projections_ResultReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.partition != rhs.partition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResultResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResultResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResultResp, rhs: EventStore_Client_Projections_ResultResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResetReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResetReq, rhs: EventStore_Client_Projections_ResetReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResetReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_ResetReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "write_checkpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.writeCheckpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.writeCheckpoint != false {
      try visitor.visitSingularBoolField(value: self.writeCheckpoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResetReq.Options, rhs: EventStore_Client_Projections_ResetReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.writeCheckpoint != rhs.writeCheckpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_ResetResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_ResetResp, rhs: EventStore_Client_Projections_ResetResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_EnableReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_EnableReq, rhs: EventStore_Client_Projections_EnableReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_EnableReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_EnableReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_EnableReq.Options, rhs: EventStore_Client_Projections_EnableReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_EnableResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnableResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_EnableResp, rhs: EventStore_Client_Projections_EnableResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DisableReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisableReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DisableReq, rhs: EventStore_Client_Projections_DisableReq) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DisableReq.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = EventStore_Client_Projections_DisableReq.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "write_checkpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.writeCheckpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.writeCheckpoint != false {
      try visitor.visitSingularBoolField(value: self.writeCheckpoint, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DisableReq.Options, rhs: EventStore_Client_Projections_DisableReq.Options) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.writeCheckpoint != rhs.writeCheckpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventStore_Client_Projections_DisableResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisableResp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: EventStore_Client_Projections_DisableResp, rhs: EventStore_Client_Projections_DisableResp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
